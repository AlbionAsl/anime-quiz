AnimeCard.tsx<

// src/components/AnimeCard.tsx

import React from 'react';
import {
  StyleSheet,
  Image,
  View,
  Dimensions,
  TouchableOpacity,
} from 'react-native';
import {
  Card,
  Text,
  useTheme,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface AnimeCardProps {
  anime: {
    id: number | null;
    title: string;
    coverImage: string | { uri: string };
  };
  onPress: () => void;
  hasPlayedToday?: boolean;
  todayScore?: number;
  totalQuestions?: number;
}

const { width } = Dimensions.get('window');
const isSmallScreen = width < 380;
const cardWidth = isSmallScreen 
  ? (width - 32) / 2 - 8 
  : (width - 48) / 3 - 8;

const AnimeCard: React.FC<AnimeCardProps> = ({
  anime,
  onPress,
  hasPlayedToday,
  todayScore,
  totalQuestions = 10,
}) => {
  const theme = useTheme();

  const imageSource = typeof anime.coverImage === 'string' 
    ? { uri: anime.coverImage }
    : anime.coverImage;

  return (
    <TouchableOpacity onPress={onPress} activeOpacity={0.8}>
      <Card style={[styles.card, { width: cardWidth }]}>
        <View style={styles.imageContainer}>
          <Image
            source={imageSource}
            style={styles.image}
            resizeMode="cover"
          />
          
          {hasPlayedToday && (
            <View style={[styles.overlay, { backgroundColor: 'rgba(0,0,0,0.7)' }]}>
              <MaterialCommunityIcons
                name="check-circle"
                size={40}
                color={theme.colors.primary}
              />
              <Text style={styles.scoreText}>
                {todayScore}/{totalQuestions}
              </Text>
              <Text style={styles.playedText}>Played Today</Text>
            </View>
          )}
          
          {anime.id === null && (
            <View style={[styles.allBadge, { backgroundColor: theme.colors.primary }]}>
              <MaterialCommunityIcons name="infinity" size={20} color="white" />
            </View>
          )}
        </View>
        
        <Card.Content style={styles.content}>
          <Text 
            style={[styles.title, { color: theme.colors.onSurface }]} 
            numberOfLines={2}
            ellipsizeMode="tail"
          >
            {anime.title}
          </Text>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    marginVertical: 4,
    elevation: 3,
    borderRadius: 12,
    overflow: 'hidden',
  },
  imageContainer: {
    position: 'relative',
    width: '100%',
    height: cardWidth * 1.4,
  },
  image: {
    width: '100%',
    height: '100%',
  },
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scoreText: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 8,
  },
  playedText: {
    color: 'white',
    fontSize: 12,
    marginTop: 4,
    opacity: 0.9,
  },
  allBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    borderRadius: 20,
    padding: 8,
  },
  content: {
    paddingVertical: 12,
    paddingHorizontal: 8,
    minHeight: 60,
    justifyContent: 'center',
  },
  title: {
    fontSize: isSmallScreen ? 13 : 14,
    fontWeight: '600',
    textAlign: 'center',
    lineHeight: 18,
  },
});

export default AnimeCard;

END OF AnimeCard.tsx>

DailyQuizStatus.tsx<

// src/components/DailyQuizStatus.tsx

import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Surface, Text, useTheme, ProgressBar } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface DailyAttempt {
  category: string;
  score: number;
  totalQuestions: number;
}

interface DailyQuizStatusProps {
  attempts: DailyAttempt[];
  timeUntilReset?: {
    hours: number;
    minutes: number;
    seconds: number;
  };
}

const DailyQuizStatus: React.FC<DailyQuizStatusProps> = ({ attempts, timeUntilReset }) => {
  const theme = useTheme();

  if (attempts.length === 0 && !timeUntilReset) {
    return null;
  }

  const totalScore = attempts.reduce((sum, attempt) => sum + attempt.score, 0);
  const totalPossible = attempts.reduce((sum, attempt) => sum + attempt.totalQuestions, 0);
  const percentage = totalPossible > 0 ? totalScore / totalPossible : 0;

  return (
    <Surface style={styles.container} elevation={1}>
      <View style={styles.header}>
        <MaterialCommunityIcons
          name="calendar-today"
          size={20}
          color={theme.colors.primary}
        />
        <Text style={styles.title}>Today's Progress</Text>
      </View>
      
      {attempts.length > 0 && (
        <>
          <View style={styles.content}>
            <Text style={styles.scoreText}>
              {totalScore} / {totalPossible} correct
            </Text>
            <Text style={styles.categoryText}>
              {attempts.length} quiz{attempts.length !== 1 ? 'zes' : ''} completed
            </Text>
          </View>
          
          <ProgressBar
            progress={percentage}
            color={theme.colors.primary}
            style={styles.progressBar}
          />
        </>
      )}
      
      {timeUntilReset && (
        <View style={styles.resetTimer}>
          <MaterialCommunityIcons
            name="clock-outline"
            size={16}
            color={theme.colors.onSurfaceVariant}
          />
          <Text style={styles.resetText}>
            Resets in {timeUntilReset.hours}h {timeUntilReset.minutes}m {timeUntilReset.seconds}s
          </Text>
        </View>
      )}
    </Surface>
  );
};

const styles = StyleSheet.create({
  container: {
    margin: 16,
    padding: 16,
    borderRadius: 12,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  content: {
    marginBottom: 12,
  },
  scoreText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  categoryText: {
    fontSize: 14,
    opacity: 0.7,
  },
  progressBar: {
    height: 8,
    borderRadius: 4,
  },
  resetTimer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  resetText: {
    fontSize: 14,
    marginLeft: 6,
    opacity: 0.7,
  },
});

export default DailyQuizStatus;

END OF DailyQuizStatus.tsx>

AppNavigator.tsx<

// src/navigation/AppNavigator.tsx

import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { ActivityIndicator, View, StyleSheet } from 'react-native';
import { useTheme } from 'react-native-paper';
import { onAuthStateChanged, User } from 'firebase/auth';
import { doc, onSnapshot } from 'firebase/firestore';
import { auth, firestore } from '../utils/firebase';

// Import screens
import LoginScreen from '../screens/LoginScreen';
import RegisterScreen from '../screens/RegisterScreen';
import UserCreationScreen from '../screens/UserCreationScreen';
import MainTabNavigator from './MainTabNavigator';

export type RootStackParamList = {
  Login: undefined;
  Register: undefined;
  UserCreation: undefined;
  MainTabs: undefined;
};

const Stack = createStackNavigator<RootStackParamList>();

const AppNavigator: React.FC = () => {
  const theme = useTheme();
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [hasProfile, setHasProfile] = useState(false);
  const [profileLoading, setProfileLoading] = useState(true);

  useEffect(() => {
    let profileUnsubscribe: (() => void) | null = null;

    const authUnsubscribe = onAuthStateChanged(auth, (currentUser) => {
      if (currentUser) {
        setUser(currentUser);
        setProfileLoading(true);
        
        // Clean up previous profile listener
        if (profileUnsubscribe) {
          profileUnsubscribe();
        }
        
        // Listen for real-time updates to user profile
        const userDocRef = doc(firestore, 'users', currentUser.uid);
        profileUnsubscribe = onSnapshot(
          userDocRef,
          (docSnap) => {
            setHasProfile(docSnap.exists());
            setProfileLoading(false);
            setLoading(false);
          },
          (error) => {
            console.error('Error listening to user profile:', error);
            setHasProfile(false);
            setProfileLoading(false);
            setLoading(false);
          }
        );
      } else {
        setUser(null);
        setHasProfile(false);
        setProfileLoading(false);
        setLoading(false);
        
        // Clean up profile listener when user signs out
        if (profileUnsubscribe) {
          profileUnsubscribe();
          profileUnsubscribe = null;
        }
      }
    });

    return () => {
      authUnsubscribe();
      if (profileUnsubscribe) {
        profileUnsubscribe();
      }
    };
  }, []);

  if (loading || (user && profileLoading)) {
    return (
      <View style={[styles.loadingContainer, { backgroundColor: theme.colors.background }]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <Stack.Navigator
        screenOptions={{
          headerShown: false,
          cardStyle: { backgroundColor: theme.colors.background },
        }}
      >
        {user ? (
          hasProfile ? (
            <Stack.Screen name="MainTabs" component={MainTabNavigator} />
          ) : (
            <Stack.Screen name="UserCreation" component={UserCreationScreen} />
          )
        ) : (
          <>
            <Stack.Screen name="Login" component={LoginScreen} />
            <Stack.Screen name="Register" component={RegisterScreen} />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default AppNavigator;

END OF AppNavigator.tsx>

MainTabNavigator.tsx<

// src/navigation/MainTabNavigator.tsx

import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useTheme } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';

// Import screens
import PlayNavigator from './PlayNavigator';
import RankingsScreen from '../screens/RankingsScreen';
import ProfileScreen from '../screens/ProfileScreen';

export type MainTabParamList = {
  Play: undefined;
  Rankings: undefined;
  Profile: undefined;
};

const Tab = createBottomTabNavigator<MainTabParamList>();

const MainTabNavigator: React.FC = () => {
  const theme = useTheme();

  return (
    <Tab.Navigator
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.onSurfaceVariant,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.outline,
          borderTopWidth: 1,
          height: 60,
          paddingBottom: 8,
          paddingTop: 8,
        },
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
      }}
    >
      <Tab.Screen
        name="Play"
        component={PlayNavigator}
        options={{
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="gamepad-variant" size={size} color={color} />
          ),
        }}
      />
      <Tab.Screen
        name="Rankings"
        component={RankingsScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="trophy" size={size} color={color} />
          ),
        }}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="account" size={size} color={color} />
          ),
        }}
      />
    </Tab.Navigator>
  );
};

export default MainTabNavigator;

END OF MainTabNavigator.tsx>

PlayNavigator.tsx<

// src/navigation/PlayNavigator.tsx

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import PlayScreen from '../screens/PlayScreen';
import QuizScreen from '../screens/QuizScreen';

export type PlayStackParamList = {
  PlayHome: {
    refresh?: boolean;
    completedCategory?: string;
    score?: number;
    totalQuestions?: number;
  } | undefined;
  Quiz: {
    animeId: number | null;
    animeName: string;
  };
};

const Stack = createStackNavigator<PlayStackParamList>();

const PlayNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="PlayHome" component={PlayScreen} />
      <Stack.Screen name="Quiz" component={QuizScreen} />
    </Stack.Navigator>
  );
};

export default PlayNavigator;

END OF PlayNavigator.tsx>

types.ts<

// src/navigation/types.ts

export type RootStackParamList = {
  Login: undefined;
  Register: undefined;
  UserCreation: undefined;
  MainTabs: undefined;
};

export type MainTabParamList = {
  Play: undefined;
  Rankings: undefined;
  Profile: undefined;
};

export type PlayStackParamList = {
  PlayHome: undefined;
  Quiz: {
    animeId: number | null;
    animeName: string;
  };
};

END OF types.ts>

PlayScreen.tsx<

// src/screens/PlayScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  SafeAreaView,
  Dimensions,
  RefreshControl,
} from 'react-native';
import {
  Text,
  Surface,
  useTheme,
  ActivityIndicator,
  Snackbar,
} from 'react-native-paper';
import { collection, getDocs, query, where, doc, getDoc } from 'firebase/firestore';
import { firestore, auth } from '../utils/firebase';
import { useNavigation, useRoute, useFocusEffect } from '@react-navigation/native';
import { StackNavigationProp, StackScreenProps } from '@react-navigation/stack';
import { PlayStackParamList } from '../navigation/PlayNavigator';
import AnimeCard from '../components/AnimeCard';
import DailyQuizStatus from '../components/DailyQuizStatus';
import { getUTCDateString, getTimeUntilReset } from '../utils/quizUtils';

type PlayScreenNavigationProp = StackNavigationProp<PlayStackParamList, 'PlayHome'>;

interface AnimeItem {
  id: number | null;
  title: string;
  coverImage: string | { uri: string };
  popularity?: number;
  hasPlayedToday?: boolean;
  todayScore?: number;
}

interface DailyAttempt {
  userId: string;
  date: string;
  category: string;
  score: number;
  totalQuestions: number;
  completedAt: Date;
}

const { width } = Dimensions.get('window');
const isSmallScreen = width < 380;

type PlayScreenProps = StackScreenProps<PlayStackParamList, 'PlayHome'>;

const PlayScreen: React.FC<PlayScreenProps> = ({ route }) => {
  const theme = useTheme();
  const navigation = useNavigation<PlayScreenNavigationProp>();
  const [animeList, setAnimeList] = useState<AnimeItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dailyAttempts, setDailyAttempts] = useState<Record<string, DailyAttempt>>({});
  const [timeUntilReset, setTimeUntilReset] = useState(getTimeUntilReset());
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  // Handle navigation params and refresh
  useFocusEffect(
    React.useCallback(() => {
      if (route.params?.refresh) {
        checkDailyAttempts();
        if (route.params.completedCategory && route.params.score !== undefined) {
          setSuccessMessage(`Quiz completed! Score: ${route.params.score}/${route.params.totalQuestions || 10}`);
          setTimeout(() => setSuccessMessage(null), 3000);
        }
        // Clear params to prevent showing message again
        navigation.setParams({ 
          refresh: undefined, 
          completedCategory: undefined, 
          score: undefined,
          totalQuestions: undefined 
        } as any);
      }
    }, [route.params])
  );

  // Update timer every second
  useEffect(() => {
    const interval = setInterval(() => {
      setTimeUntilReset(getTimeUntilReset());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  const checkDailyAttempts = async () => {
    try {
      const user = auth.currentUser;
      if (!user) return;

      const todayDate = getUTCDateString();
      const attemptsQuery = query(
        collection(firestore, 'dailyQuizzes'),
        where('userId', '==', user.uid),
        where('date', '==', todayDate)
      );

      const snapshot = await getDocs(attemptsQuery);
      const attempts: Record<string, DailyAttempt> = {};

      snapshot.forEach((doc) => {
        const data = doc.data() as DailyAttempt;
        attempts[data.category] = data;
      });

      setDailyAttempts(attempts);
    } catch (error) {
      console.error('Error checking daily attempts:', error);
    }
  };

  const fetchAnimes = async () => {
    try {
      // First add the "All" category
      const allCategory: AnimeItem = {
        id: null,
        title: 'All Anime',
        coverImage: 'https://via.placeholder.com/300x450/6C5CE7/FFFFFF?text=ALL+ANIME',
      };

      // Fetch anime from Firestore
      const animesSnapshot = await getDocs(collection(firestore, 'animes'));
      const animes: AnimeItem[] = [allCategory];

      animesSnapshot.forEach((doc) => {
        const data = doc.data();
        if (data.id && data.title && data.coverImage) {
          animes.push({
            id: data.id,
            title: data.title,
            coverImage: data.coverImage,
            popularity: data.popularity || 0,
          });
        }
      });

      // Sort by popularity (keeping "All" first)
      const sortedAnimes = [
        allCategory,
        ...animes.slice(1).sort((a, b) => (b.popularity || 0) - (a.popularity || 0)),
      ];

      setAnimeList(sortedAnimes);
      setError(null);
    } catch (error) {
      console.error('Error fetching anime:', error);
      setError('Failed to load anime. Please try again.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    fetchAnimes();
    checkDailyAttempts();
  }, []);

  const handleRefresh = async () => {
    setRefreshing(true);
    await Promise.all([fetchAnimes(), checkDailyAttempts()]);
  };

  const handleAnimePress = (animeId: number | null, animeName: string) => {
    const category = animeId === null ? 'all' : animeId.toString();
    const attempt = dailyAttempts[category];

    if (attempt) {
      // Show score if already played today
      setError(`You already played ${animeName} today! Score: ${attempt.score}/${attempt.totalQuestions}`);
      return;
    }

    navigation.navigate('Quiz', {
      animeId,
      animeName,
    });
  };

  const renderAnimeCard = ({ item }: { item: AnimeItem }) => {
    const category = item.id === null ? 'all' : item.id.toString();
    const attempt = dailyAttempts[category];

    return (
      <View style={styles.cardWrapper}>
        <AnimeCard
          anime={item}
          onPress={() => handleAnimePress(item.id, item.title)}
          hasPlayedToday={!!attempt}
          todayScore={attempt?.score}
          totalQuestions={attempt?.totalQuestions}
        />
      </View>
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading anime...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <Surface style={styles.header} elevation={2}>
        <Text style={styles.title}>Anime Quiz</Text>
        <Text style={styles.subtitle}>Choose an anime to start your daily quiz</Text>
      </Surface>

      <DailyQuizStatus 
        attempts={Object.values(dailyAttempts)} 
        timeUntilReset={timeUntilReset}
      />

      <FlatList
        data={animeList}
        renderItem={renderAnimeCard}
        keyExtractor={(item) => item.id?.toString() || 'all'}
        numColumns={isSmallScreen ? 2 : 3}
        columnWrapperStyle={isSmallScreen ? styles.row : styles.rowLarge}
        contentContainerStyle={styles.listContainer}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>No anime available</Text>
          </View>
        }
      />

      <Snackbar
        visible={!!error}
        onDismiss={() => setError(null)}
        duration={3000}
        style={{ backgroundColor: theme.colors.error }}
      >
        {error}
      </Snackbar>

      <Snackbar
        visible={!!successMessage}
        onDismiss={() => setSuccessMessage(null)}
        duration={3000}
        style={{ backgroundColor: theme.colors.primary }}
      >
        {successMessage}
      </Snackbar>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 12,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 14,
    textAlign: 'center',
    opacity: 0.8,
  },
  listContainer: {
    paddingHorizontal: 8,
    paddingBottom: 20,
  },
  row: {
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  rowLarge: {
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  cardWrapper: {
    flex: 1,
    padding: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    fontSize: 16,
    opacity: 0.6,
  },
});

export default PlayScreen;

END OF PlayScreen.tsx>

QuizScreen.tsx<

// src/screens/QuizScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Dimensions,
  BackHandler,
} from 'react-native';
import {
  Text,
  Button,
  Surface,
  useTheme,
  ActivityIndicator,
  ProgressBar,
  Dialog,
  Portal,
  IconButton,
} from 'react-native-paper';
import { useRoute, useNavigation, RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { PlayStackParamList } from '../navigation/PlayNavigator';
import { collection, query, where, getDocs, addDoc, doc, updateDoc, increment } from 'firebase/firestore';
import { firestore, auth } from '../utils/firebase';
import { getDailyQuestions, getUTCDateString } from '../utils/quizUtils';
import { updateRankings } from '../utils/rankingUtils';

type QuizScreenRouteProp = RouteProp<PlayStackParamList, 'Quiz'>;
type QuizScreenNavigationProp = StackNavigationProp<PlayStackParamList, 'Quiz'>;

interface Question {
  id: string;
  question: string;
  options: string[];
  correctAnswer: number;
  animeId?: number;
  animeName?: string;
}

interface Answer {
  questionId: string;
  selectedOption: number;
  isCorrect: boolean;
}

const { width, height } = Dimensions.get('window');
const isSmallScreen = width < 380;

const QuizScreen: React.FC = () => {
  const theme = useTheme();
  const route = useRoute<QuizScreenRouteProp>();
  const navigation = useNavigation<QuizScreenNavigationProp>();
  const { animeId, animeName } = route.params;

  // State declarations
  const [questions, setQuestions] = useState<Question[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState<Answer[]>([]);
  const [selectedOption, setSelectedOption] = useState<number | null>(null);
  const [showFeedback, setShowFeedback] = useState(false);
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [showExitDialog, setShowExitDialog] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchQuestions();

    // Handle hardware back button
    const backHandler = BackHandler.addEventListener('hardwareBackPress', () => {
      if (!showResults) {
        setShowExitDialog(true);
        return true;
      }
      return false;
    });

    return () => backHandler.remove();
  }, [showResults]);

  const fetchQuestions = async () => {
    try {
      setLoading(true);
      
      // Use the new getDailyQuestions utility for consistent daily questions
      const dailyQuestions = await getDailyQuestions(animeId, 10);

      if (dailyQuestions.length === 0) {
        setError('No questions available for this category');
        setLoading(false);
        return;
      }

      setQuestions(dailyQuestions);
      setLoading(false);
    } catch (error) {
      console.error('Error fetching questions:', error);
      setError('Failed to load questions. Please try again.');
      setLoading(false);
    }
  };

  const handleSelectOption = (optionIndex: number) => {
    if (selectedOption !== null || showFeedback) return;

    setSelectedOption(optionIndex);
    setShowFeedback(true);

    const currentQuestion = questions[currentQuestionIndex];
    const isCorrect = optionIndex === currentQuestion.correctAnswer;

    // Record the answer
    const newAnswer: Answer = {
      questionId: currentQuestion.id,
      selectedOption: optionIndex,
      isCorrect,
    };

    const updatedAnswers = [...answers, newAnswer];
    setAnswers(updatedAnswers);

    // Auto-advance after showing feedback
    setTimeout(() => {
      if (currentQuestionIndex < questions.length - 1) {
        setCurrentQuestionIndex(currentQuestionIndex + 1);
        setSelectedOption(null);
        setShowFeedback(false);
      } else {
        // Last question - submit quiz
        submitQuiz(updatedAnswers);
      }
    }, 1500); // Show feedback for 1.5 seconds
  };

  const submitQuiz = async (finalAnswers: Answer[]) => {
    setSubmitting(true);
    try {
      const user = auth.currentUser;
      if (!user) throw new Error('User not authenticated');

      const score = finalAnswers.filter(a => a.isCorrect).length;
      
      const category = animeId === null ? 'all' : animeId.toString();
      const todayDate = getUTCDateString();

      // Save quiz attempt
      await addDoc(collection(firestore, 'dailyQuizzes'), {
        userId: user.uid,
        date: todayDate,
        category,
        animeName,
        score,
        totalQuestions: questions.length,
        completedAt: new Date(),
        answers: finalAnswers,
      });

      // Update user statistics
      const userRef = doc(firestore, 'users', user.uid);
      await updateDoc(userRef, {
        totalQuizzes: increment(1),
        totalCorrectAnswers: increment(score),
        [`categoryScores.${category}`]: increment(score),
      });

      // Update rankings
      await updateRankings(user.uid, category, score, questions.length);

      setShowResults(true);
      
    } catch (error) {
      console.error('Error submitting quiz:', error);
      setError('Failed to submit quiz. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const handleExit = () => {
    setShowExitDialog(false);
    navigation.goBack();
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading questions...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>{error}</Text>
        <Button mode="contained" onPress={() => navigation.goBack()}>
          Go Back
        </Button>
      </View>
    );
  }

  if (showResults) {
    const score = answers.filter(a => a.isCorrect).length;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
        <View style={styles.resultsWrapper}>
          <Surface style={styles.resultsContainer} elevation={2}>
            <Text style={styles.resultTitle}>Quiz Complete!</Text>
            <Text style={styles.categoryText}>{animeName}</Text>
            
            <View style={styles.scoreCircle}>
              <Text style={styles.scoreNumber}>{score}</Text>
              <Text style={styles.scoreDivider}>/</Text>
              <Text style={styles.scoreTotal}>10</Text>
            </View>
            
            <Button
              mode="contained"
              onPress={() => {
                const score = answers.filter(a => a.isCorrect).length;
                const category = animeId === null ? 'all' : animeId.toString();
                navigation.navigate('PlayHome', { 
                  refresh: true,
                  completedCategory: category,
                  score: score,
                  totalQuestions: 10
                });
              }}
              style={styles.finishButton}
            >
              Finish
            </Button>
          </Surface>
        </View>
      </SafeAreaView>
    );
  }

  const currentQuestion = questions[currentQuestionIndex];
  const progress = (currentQuestionIndex + 1) / questions.length;

  if (submitting) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Submitting quiz...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <View style={styles.header}>
        <IconButton
          icon="arrow-left"
          size={24}
          onPress={() => setShowExitDialog(true)}
        />
        <Text style={styles.questionCounter}>
          Question {currentQuestionIndex + 1} of {questions.length}
        </Text>
        <View style={{ width: 48 }} />
      </View>

      <ProgressBar progress={progress} color={theme.colors.primary} style={styles.mainProgressBar} />

      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.questionCard} elevation={2}>
          <Text style={[styles.questionText, isSmallScreen && styles.questionTextSmall]}>
            {currentQuestion.question}
          </Text>
        </Surface>

        <View style={styles.optionsContainer}>
          {currentQuestion.options.map((option, index) => {
            const isSelected = selectedOption === index;
            const isCorrect = index === currentQuestion.correctAnswer;
            const showCorrect = showFeedback && isCorrect;
            const showIncorrect = showFeedback && isSelected && !isCorrect;

            return (
              <Surface
                key={index}
                style={[
                  styles.optionCard,
                  showCorrect && styles.correctOption,
                  showIncorrect && styles.incorrectOption,
                ]}
                elevation={1}
              >
                <Button
                  mode="text"
                  onPress={() => handleSelectOption(index)}
                  style={styles.optionButton}
                  labelStyle={[
                    styles.optionText,
                    (showCorrect || showIncorrect) && styles.feedbackOptionText,
                    isSmallScreen && styles.optionTextSmall,
                  ]}
                  contentStyle={styles.optionContent}
                  disabled={showFeedback || submitting}
                >
                  {String.fromCharCode(65 + index)}. {option}
                </Button>
              </Surface>
            );
          })}
        </View>
      </ScrollView>

      <Portal>
        <Dialog visible={showExitDialog} onDismiss={() => setShowExitDialog(false)}>
          <Dialog.Title>Exit Quiz?</Dialog.Title>
          <Dialog.Content>
            <Text>Are you sure you want to exit? Your progress will be lost.</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowExitDialog(false)}>Cancel</Button>
            <Button onPress={handleExit}>Exit</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    marginBottom: 20,
    textAlign: 'center',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 4,
    paddingVertical: 8,
  },
  questionCounter: {
    fontSize: 16,
    fontWeight: '600',
  },
  mainProgressBar: {
    height: 6,
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 3,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 16,
    paddingBottom: 20,
  },
  questionCard: {
    padding: 20,
    borderRadius: 12,
    marginBottom: 24,
    minHeight: 120,
    justifyContent: 'center',
  },
  questionText: {
    fontSize: 18,
    lineHeight: 26,
    fontWeight: '500',
  },
  questionTextSmall: {
    fontSize: 16,
    lineHeight: 24,
  },
  optionsContainer: {
    gap: 12,
  },
  optionCard: {
    borderRadius: 12,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: 'transparent',
  },
  correctOption: {
    borderColor: '#4CAF50',
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
  },
  incorrectOption: {
    borderColor: '#F44336',
    backgroundColor: 'rgba(244, 67, 54, 0.1)',
  },
  optionButton: {
    paddingVertical: 8,
    paddingHorizontal: 0,
  },
  optionContent: {
    height: 'auto',
    minHeight: 60,
    justifyContent: 'flex-start',
    paddingHorizontal: 16,
  },
  optionText: {
    fontSize: 16,
    textAlign: 'left',
    flex: 1,
    lineHeight: 22,
  },
  optionTextSmall: {
    fontSize: 14,
    lineHeight: 20,
  },
  feedbackOptionText: {
    fontWeight: '600',
  },
  resultsWrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  resultsContainer: {
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    width: '100%',
    maxWidth: 320,
  },
  resultTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  categoryText: {
    fontSize: 18,
    opacity: 0.8,
    marginBottom: 24,
  },
  scoreCircle: {
    flexDirection: 'row',
    alignItems: 'baseline',
    marginBottom: 8,
  },
  scoreNumber: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#6C5CE7', // Primary color
  },
  scoreDivider: {
    fontSize: 36,
    marginHorizontal: 4,
    opacity: 0.6,
  },
  scoreTotal: {
    fontSize: 36,
    opacity: 0.8,
  },
  finishButton: {
    paddingHorizontal: 32,
    paddingVertical: 8,
    borderRadius: 8,
    marginTop: 24,
  },
});

export default QuizScreen;

END OF QuizScreen.tsx>

RankingsScreen.tsx<

// src/screens/RankingsScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  RefreshControl,
  Dimensions,
} from 'react-native';
import {
  Text,
  Surface,
  useTheme,
  ActivityIndicator,
  Chip,
  Menu,
  Button,
  IconButton,
  Divider,
  Avatar,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { onSnapshot, doc } from 'firebase/firestore';
import { firestore, auth } from '../utils/firebase';
import {
  getLeaderboardData,
  getUserRank,
  getAvailableCategories,
  getMonthString,
} from '../utils/rankingUtils';
import { getUTCDateString } from '../utils/quizUtils';

const { width } = Dimensions.get('window');
const isSmallScreen = width < 380;

type Period = 'daily' | 'monthly' | 'allTime';
type RankingType = 'totalScore' | 'averageScore';

interface LeaderboardPlayer {
  userId: string;
  username: string;
  score: number;
  totalQuestions: number;
  averageScore: number;
  quizCount: number;
  rank: number;
}

interface Category {
  id: string;
  title: string;
}

interface UserRankData {
  rank: number;
  totalPlayers: number;
  score: number;
  averageScore: number;
}

const RankingsScreen: React.FC = () => {
  const theme = useTheme();
  const currentUser = auth.currentUser;

  // State
  const [selectedPeriod, setSelectedPeriod] = useState<Period>('daily');
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const [selectedCategoryTitle, setSelectedCategoryTitle] = useState<string>('All Anime');
  const [rankingType, setRankingType] = useState<RankingType>('totalScore');
  const [categories, setCategories] = useState<Category[]>([]);
  const [leaderboardData, setLeaderboardData] = useState<LeaderboardPlayer[]>([]);
  const [userRank, setUserRank] = useState<UserRankData | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [menuVisible, setMenuVisible] = useState(false);
  const [totalPlayers, setTotalPlayers] = useState(0);

  // Get period value based on selected period
  const getPeriodValue = (): string => {
    switch (selectedPeriod) {
      case 'daily':
        return getUTCDateString();
      case 'monthly':
        return getMonthString();
      case 'allTime':
        return 'all';
      default:
        return getUTCDateString();
    }
  };

  // Fetch categories on mount
  useEffect(() => {
    fetchCategories();
  }, []);

  // Set up real-time listener for leaderboard
  useEffect(() => {
    const periodValue = getPeriodValue();
    const cacheId = `${selectedPeriod}_${periodValue}_${selectedCategory}`;
    
    const unsubscribe = onSnapshot(
      doc(firestore, 'leaderboardCache', cacheId),
      (snapshot) => {
        if (snapshot.exists()) {
          const data = snapshot.data();
          let players = data.topPlayers || [];
          
          // Sort by average score if that's the selected ranking type
          if (rankingType === 'averageScore') {
            players = [...players]
              .filter(p => selectedPeriod === 'allTime' ? p.quizCount >= 20 : true)
              .sort((a, b) => b.averageScore - a.averageScore)
              .map((p, index) => ({ ...p, rank: index + 1 }));
          }
          
          setLeaderboardData(players);
          setTotalPlayers(data.totalPlayers || players.length);
          setLoading(false);
        } else {
          setLeaderboardData([]);
          setTotalPlayers(0);
          setLoading(false);
        }
      },
      (error) => {
        console.error('Error listening to leaderboard:', error);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [selectedPeriod, selectedCategory, rankingType]);

  // Fetch user rank whenever period/category changes
  useEffect(() => {
    if (currentUser) {
      fetchUserRank();
    }
  }, [selectedPeriod, selectedCategory, currentUser]);

  const fetchCategories = async () => {
    try {
      const availableCategories = await getAvailableCategories();
      setCategories(availableCategories);
    } catch (error) {
      console.error('Error fetching categories:', error);
    }
  };

  const fetchUserRank = async () => {
    if (!currentUser) return;

    try {
      const periodValue = getPeriodValue();
      const rankData = await getUserRank(
        currentUser.uid,
        selectedPeriod,
        periodValue,
        selectedCategory
      );
      setUserRank(rankData);
    } catch (error) {
      console.error('Error fetching user rank:', error);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await Promise.all([fetchCategories(), fetchUserRank()]);
    setRefreshing(false);
  };

  const handleCategorySelect = (categoryId: string, categoryTitle: string) => {
    setSelectedCategory(categoryId);
    setSelectedCategoryTitle(categoryTitle);
    setMenuVisible(false);
  };

  const getPeriodChips = () => [
    { id: 'daily', label: 'Daily', icon: 'calendar-today' },
    { id: 'monthly', label: 'Monthly', icon: 'calendar-month' },
    { id: 'allTime', label: 'All Time', icon: 'infinity' },
  ];

  const getRankingTypeChips = () => [
    { id: 'totalScore', label: 'Total Score', icon: 'numeric' },
    { id: 'averageScore', label: 'Average Score', icon: 'percent' },
  ];

  const renderLeaderboardItem = (player: LeaderboardPlayer, index: number) => {
    const isCurrentUser = currentUser?.uid === player.userId;
    const showQuizCount = selectedPeriod === 'allTime' && rankingType === 'averageScore';

    return (
      <Surface
        key={player.userId}
        style={[
          styles.leaderboardItem,
          isCurrentUser && styles.currentUserItem,
          { backgroundColor: isCurrentUser ? theme.colors.primaryContainer : theme.colors.surface }
        ]}
        elevation={isCurrentUser ? 2 : 1}
      >
        <View style={styles.rankContainer}>
          {player.rank <= 3 ? (
            <MaterialCommunityIcons
              name={player.rank === 1 ? 'trophy' : player.rank === 2 ? 'medal' : 'medal-outline'}
              size={24}
              color={
                player.rank === 1 ? '#FFD700' : 
                player.rank === 2 ? '#C0C0C0' : 
                '#CD7F32'
              }
            />
          ) : (
            <Text style={styles.rankText}>#{player.rank}</Text>
          )}
        </View>

        <View style={styles.playerInfo}>
          <Avatar.Text
            size={36}
            label={player.username.substring(0, 2).toUpperCase()}
            style={{ backgroundColor: theme.colors.primary }}
          />
          <View style={styles.playerDetails}>
            <Text style={[styles.username, isCurrentUser && styles.currentUserText]}>
              {player.username}
              {isCurrentUser && ' (You)'}
            </Text>
            {showQuizCount && (
              <Text style={styles.quizCountText}>
                {player.quizCount} quizzes
              </Text>
            )}
          </View>
        </View>

        <View style={styles.scoreContainer}>
          <Text style={[styles.score, isCurrentUser && styles.currentUserScore]}>
            {rankingType === 'totalScore' ? player.score : `${player.averageScore.toFixed(1)}%`}
          </Text>
          {rankingType === 'totalScore' && (
            <Text style={styles.scoreSubtext}>
              {((player.score / player.totalQuestions) * 100).toFixed(1)}% avg
            </Text>
          )}
        </View>
      </Surface>
    );
  };

  if (loading && !refreshing) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading rankings...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <Surface style={styles.header} elevation={2}>
        <Text style={styles.title}>Rankings</Text>
        
        {/* Category Selector */}
        <View style={styles.categorySelector}>
          <Menu
            visible={menuVisible}
            onDismiss={() => setMenuVisible(false)}
            anchor={
              <Button
                mode="outlined"
                onPress={() => setMenuVisible(true)}
                style={styles.categoryButton}
                contentStyle={styles.categoryButtonContent}
              >
                <MaterialCommunityIcons name="gamepad-variant" size={16} />
                <Text style={styles.categoryButtonText}>{selectedCategoryTitle}</Text>
                <MaterialCommunityIcons name="chevron-down" size={16} />
              </Button>
            }
          >
            {categories.map((category) => (
              <Menu.Item
                key={category.id}
                onPress={() => handleCategorySelect(category.id, category.title)}
                title={category.title}
                leadingIcon={category.id === 'all' ? 'infinity' : 'gamepad-variant'}
              />
            ))}
          </Menu>
        </View>

        {/* Period Selector */}
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={styles.chipScrollView}
          contentContainerStyle={styles.chipContainer}
        >
          {getPeriodChips().map((period) => (
            <Chip
              key={period.id}
              selected={selectedPeriod === period.id}
              onPress={() => setSelectedPeriod(period.id as Period)}
              style={[
                styles.chip,
                selectedPeriod === period.id && { backgroundColor: theme.colors.primaryContainer }
              ]}
              textStyle={styles.chipText}
              icon={period.icon}
            >
              {period.label}
            </Chip>
          ))}
        </ScrollView>

        {/* Ranking Type Selector */}
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={styles.chipScrollView}
          contentContainerStyle={styles.chipContainer}
        >
          {getRankingTypeChips().map((type) => (
            <Chip
              key={type.id}
              selected={rankingType === type.id}
              onPress={() => setRankingType(type.id as RankingType)}
              style={[
                styles.chip,
                rankingType === type.id && { backgroundColor: theme.colors.primaryContainer }
              ]}
              textStyle={styles.chipText}
              icon={type.icon}
            >
              {type.label}
            </Chip>
          ))}
        </ScrollView>
      </Surface>

      {/* User Rank Card */}
      {userRank && currentUser && (
        <Surface style={styles.userRankCard} elevation={2}>
          <View style={styles.userRankContent}>
            <MaterialCommunityIcons
              name="account-circle"
              size={24}
              color={theme.colors.primary}
            />
            <Text style={styles.userRankText}>Your Rank</Text>
            <Text style={styles.userRankValue}>
              #{userRank.rank} / {userRank.totalPlayers}
            </Text>
            <Text style={styles.userScoreText}>
              {rankingType === 'totalScore' 
                ? `Score: ${userRank.score}`
                : `Average: ${userRank.averageScore.toFixed(1)}%`
              }
            </Text>
          </View>
        </Surface>
      )}

      {/* Leaderboard */}
      <ScrollView
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={styles.scrollContent}
      >
        {rankingType === 'averageScore' && selectedPeriod === 'allTime' && (
          <Surface style={[styles.infoCard, { backgroundColor: theme.colors.primaryContainer }]} elevation={1}>
            <MaterialCommunityIcons
              name="information-outline"
              size={20}
              color={theme.colors.primary}
            />
            <Text style={styles.infoText}>
              Average score rankings require at least 20 quizzes completed
            </Text>
          </Surface>
        )}

        {leaderboardData.length > 0 ? (
          <>
            {leaderboardData.map((player, index) => renderLeaderboardItem(player, index))}
            
            {leaderboardData.length === 100 && (
              <Text style={styles.footerText}>
                Showing top 100 players out of {totalPlayers}
              </Text>
            )}
          </>
        ) : (
          <View style={styles.emptyContainer}>
            <MaterialCommunityIcons
              name="trophy-outline"
              size={64}
              color={theme.colors.onSurfaceVariant}
            />
            <Text style={styles.emptyText}>No rankings yet</Text>
            <Text style={styles.emptySubtext}>
              Be the first to complete a quiz!
            </Text>
          </View>
        )}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 12,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 16,
  },
  categorySelector: {
    marginBottom: 12,
    alignItems: 'center',
  },
  categoryButton: {
    borderRadius: 8,
  },
  categoryButtonContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  categoryButtonText: {
    fontSize: 14,
    fontWeight: '500',
  },
  chipScrollView: {
    marginBottom: 8,
    maxHeight: 48,
  },
  chipContainer: {
    paddingHorizontal: 4,
    gap: 8,
    alignItems: 'center',
  },
  chip: {
    marginHorizontal: 4,
  },
  chipText: {
    fontSize: 12,
  },
  userRankCard: {
    margin: 16,
    padding: 16,
    borderRadius: 12,
  },
  userRankContent: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  userRankText: {
    fontSize: 14,
    opacity: 0.8,
    flex: 1,
  },
  userRankValue: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  userScoreText: {
    fontSize: 14,
    opacity: 0.7,
    marginLeft: 8,
  },
  scrollContent: {
    paddingHorizontal: 16,
    paddingBottom: 20,
  },
  infoCard: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    padding: 12,
    marginBottom: 16,
    borderRadius: 8,
  },
  infoText: {
    flex: 1,
    fontSize: 13,
    lineHeight: 18,
  },
  leaderboardItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    marginBottom: 8,
    borderRadius: 12,
  },
  currentUserItem: {
    borderWidth: 2,
  },
  rankContainer: {
    width: 40,
    alignItems: 'center',
  },
  rankText: {
    fontSize: 16,
    fontWeight: '600',
    opacity: 0.7,
  },
  playerInfo: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginLeft: 8,
  },
  playerDetails: {
    flex: 1,
  },
  username: {
    fontSize: 16,
    fontWeight: '500',
  },
  currentUserText: {
  },
  quizCountText: {
    fontSize: 12,
    opacity: 0.6,
    marginTop: 2,
  },
  scoreContainer: {
    alignItems: 'flex-end',
  },
  score: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  currentUserScore: {
  },
  scoreSubtext: {
    fontSize: 12,
    opacity: 0.6,
    marginTop: 2,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    fontSize: 18,
    fontWeight: '600',
    marginTop: 16,
    opacity: 0.8,
  },
  emptySubtext: {
    fontSize: 14,
    marginTop: 8,
    opacity: 0.6,
  },
  footerText: {
    textAlign: 'center',
    marginTop: 16,
    fontSize: 14,
    opacity: 0.6,
  },
});

export default RankingsScreen;

END OF RankingsScreen.tsx>

LoginScreen.tsx<

// src/screens/LoginScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import {
  Button,
  Text,
  TextInput,
  Surface,
  useTheme,
  IconButton,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { signInWithEmailAndPassword } from 'firebase/auth';
import { auth } from '../utils/firebase';

type LoginScreenProps = {
  navigation: any;
};

const LoginScreen: React.FC<LoginScreenProps> = ({ navigation }) => {
  const theme = useTheme();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [showEmailLogin, setShowEmailLogin] = useState(false);

  const handleEmailLogin = async () => {
    if (!email || !password) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    setLoading(true);
    try {
      await signInWithEmailAndPassword(auth, email, password);
      // Navigation will be handled by the auth state listener
    } catch (error: any) {
      Alert.alert('Login Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleLogin = async () => {
    Alert.alert('Coming Soon', 'Google sign-in will be implemented soon!');
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContainer: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
      paddingVertical: 40,
    },
    surface: {
      padding: 24,
      borderRadius: 16,
      marginBottom: 24,
      elevation: 4,
    },
    title: {
      fontSize: 32,
      fontWeight: 'bold',
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 8,
    },
    subtitle: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 32,
    },
    socialButtonsContainer: {
      gap: 16,
      marginBottom: 24,
    },
    socialButton: {
      paddingVertical: 12,
      borderRadius: 12,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    socialButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 12,
    },
    socialButtonText: {
      fontSize: 16,
      fontWeight: '500',
    },
    dividerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: 24,
      gap: 16,
    },
    dividerLine: {
      flex: 1,
      height: 1,
      backgroundColor: theme.colors.outline,
    },
    dividerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emailContainer: {
      gap: 16,
    },
    textInput: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
    },
    passwordContainer: {
      position: 'relative',
    },
    loginButton: {
      paddingVertical: 12,
      borderRadius: 12,
      marginTop: 8,
    },
    backButton: {
      alignSelf: 'center',
      marginTop: 16,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginTop: 24,
      gap: 4,
    },
    footerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    registerLink: {
      fontSize: 14,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
    },
  });

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.surface}>
          <Text style={styles.title}>Welcome Back</Text>
          <Text style={styles.subtitle}>Sign in to your account</Text>

          {!showEmailLogin ? (
            <>
              <View style={styles.socialButtonsContainer}>
                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={handleGoogleLogin}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Google</Text>
                  </View>
                </Button>

                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={() => setShowEmailLogin(true)}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Email</Text>
                  </View>
                </Button>
              </View>
            </>
          ) : (
            <>
              <View style={styles.dividerContainer}>
                <View style={styles.dividerLine} />
                <Text style={styles.dividerText}>Email Login</Text>
                <View style={styles.dividerLine} />
              </View>

              <View style={styles.emailContainer}>
                <TextInput
                  mode="outlined"
                  label="Email"
                  value={email}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                  style={styles.textInput}
                  disabled={loading}
                />

                <View style={styles.passwordContainer}>
                  <TextInput
                    mode="outlined"
                    label="Password"
                    value={password}
                    onChangeText={setPassword}
                    secureTextEntry={!showPassword}
                    style={styles.textInput}
                    disabled={loading}
                    right={
                      <TextInput.Icon
                        icon={showPassword ? 'eye-off' : 'eye'}
                        onPress={() => setShowPassword(!showPassword)}
                      />
                    }
                  />
                </View>

                <Button
                  mode="contained"
                  onPress={handleEmailLogin}
                  style={styles.loginButton}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.colors.onPrimary} />
                      <Text style={{ color: theme.colors.onPrimary }}>Signing in...</Text>
                    </View>
                  ) : (
                    'Sign In'
                  )}
                </Button>

                <Button
                  mode="text"
                  onPress={() => setShowEmailLogin(false)}
                  style={styles.backButton}
                  disabled={loading}
                >
                  Back to options
                </Button>
              </View>
            </>
          )}

          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account?</Text>
            <Button
              mode="text"
              onPress={() => navigation.navigate('Register')}
              disabled={loading}
            >
              <Text style={styles.registerLink}>Sign up</Text>
            </Button>
          </View>
        </Surface>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default LoginScreen;

END OF LoginScreen.tsx>

RegisterScreen.tsx<

// src/screens/RegisterScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import {
  Button,
  Text,
  TextInput,
  Surface,
  useTheme,
  IconButton,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { auth } from '../utils/firebase';

type RegisterScreenProps = {
  navigation: any;
};

const RegisterScreen: React.FC<RegisterScreenProps> = ({ navigation }) => {
  const theme = useTheme();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [showEmailRegister, setShowEmailRegister] = useState(false);

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  const handleEmailRegister = async () => {
    if (!email || !password || !confirmPassword) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    if (!validateEmail(email)) {
      Alert.alert('Error', 'Please enter a valid email address');
      return;
    }

    if (password.length < 6) {
      Alert.alert('Error', 'Password must be at least 6 characters long');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('Error', 'Passwords do not match');
      return;
    }

    setLoading(true);
    try {
      await createUserWithEmailAndPassword(auth, email, password);
      // Navigation will be handled by the auth state listener
    } catch (error: any) {
      Alert.alert('Registration Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleRegister = async () => {
    Alert.alert('Coming Soon', 'Google sign-up will be implemented soon!');
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContainer: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
      paddingVertical: 40,
    },
    surface: {
      padding: 24,
      borderRadius: 16,
      marginBottom: 24,
      elevation: 4,
    },
    title: {
      fontSize: 32,
      fontWeight: 'bold',
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 8,
    },
    subtitle: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 32,
    },
    socialButtonsContainer: {
      gap: 16,
      marginBottom: 24,
    },
    socialButton: {
      paddingVertical: 12,
      borderRadius: 12,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    socialButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 12,
    },
    socialButtonText: {
      fontSize: 16,
      fontWeight: '500',
    },
    dividerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: 24,
      gap: 16,
    },
    dividerLine: {
      flex: 1,
      height: 1,
      backgroundColor: theme.colors.outline,
    },
    dividerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emailContainer: {
      gap: 16,
    },
    textInput: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
    },
    passwordContainer: {
      position: 'relative',
    },
    registerButton: {
      paddingVertical: 12,
      borderRadius: 12,
      marginTop: 8,
    },
    backButton: {
      alignSelf: 'center',
      marginTop: 16,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginTop: 24,
      gap: 4,
    },
    footerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    loginLink: {
      fontSize: 14,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
    },
  });

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.surface}>
          <Text style={styles.title}>Create Account</Text>
          <Text style={styles.subtitle}>Sign up to get started</Text>

          {!showEmailRegister ? (
            <>
              <View style={styles.socialButtonsContainer}>
                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={handleGoogleRegister}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Google</Text>
                  </View>
                </Button>

                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={() => setShowEmailRegister(true)}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Email</Text>
                  </View>
                </Button>
              </View>
            </>
          ) : (
            <>
              <View style={styles.dividerContainer}>
                <View style={styles.dividerLine} />
                <Text style={styles.dividerText}>Email Registration</Text>
                <View style={styles.dividerLine} />
              </View>

              <View style={styles.emailContainer}>
                <TextInput
                  mode="outlined"
                  label="Email"
                  value={email}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                  style={styles.textInput}
                  disabled={loading}
                />

                <View style={styles.passwordContainer}>
                  <TextInput
                    mode="outlined"
                    label="Password"
                    value={password}
                    onChangeText={setPassword}
                    secureTextEntry={!showPassword}
                    style={styles.textInput}
                    disabled={loading}
                    right={
                      <TextInput.Icon
                        icon={showPassword ? 'eye-off' : 'eye'}
                        onPress={() => setShowPassword(!showPassword)}
                      />
                    }
                  />
                </View>

                <View style={styles.passwordContainer}>
                  <TextInput
                    mode="outlined"
                    label="Confirm Password"
                    value={confirmPassword}
                    onChangeText={setConfirmPassword}
                    secureTextEntry={!showConfirmPassword}
                    style={styles.textInput}
                    disabled={loading}
                    right={
                      <TextInput.Icon
                        icon={showConfirmPassword ? 'eye-off' : 'eye'}
                        onPress={() => setShowConfirmPassword(!showConfirmPassword)}
                      />
                    }
                  />
                </View>

                <Button
                  mode="contained"
                  onPress={handleEmailRegister}
                  style={styles.registerButton}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.colors.onPrimary} />
                      <Text style={{ color: theme.colors.onPrimary }}>Creating account...</Text>
                    </View>
                  ) : (
                    'Create Account'
                  )}
                </Button>

                <Button
                  mode="text"
                  onPress={() => setShowEmailRegister(false)}
                  style={styles.backButton}
                  disabled={loading}
                >
                  Back to options
                </Button>
              </View>
            </>
          )}

          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account?</Text>
            <Button
              mode="text"
              onPress={() => navigation.navigate('Login')}
              disabled={loading}
            >
              <Text style={styles.loginLink}>Sign in</Text>
            </Button>
          </View>
        </Surface>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default RegisterScreen;

END OF RegisterScreen.tsx>

UserCreationScreen.tsx<

// src/screens/UserCreationScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import {
  Button,
  Text,
  TextInput,
  Surface,
  useTheme,
  ActivityIndicator,
  HelperText,
} from 'react-native-paper';
import { doc, setDoc, query, where, getDocs, collection } from 'firebase/firestore';
import { auth, firestore } from '../utils/firebase';

type UserCreationScreenProps = {
  navigation: any;
};

const UserCreationScreen: React.FC<UserCreationScreenProps> = ({ navigation }) => {
  const theme = useTheme();
  const [username, setUsername] = useState('');
  const [loading, setLoading] = useState(false);
  const [usernameError, setUsernameError] = useState('');
  const [checkingUsername, setCheckingUsername] = useState(false);

  const validateUsername = (username: string) => {
    const regex = /^[a-zA-Z0-9_]+$/;
    if (!username) {
      return 'Username is required';
    }
    if (username.length < 3) {
      return 'Username must be at least 3 characters long';
    }
    if (username.length > 20) {
      return 'Username must be less than 20 characters';
    }
    if (!regex.test(username)) {
      return 'Username can only contain letters, numbers, and underscores';
    }
    return '';
  };

  const checkUsernameAvailability = async (username: string) => {
    setCheckingUsername(true);
    try {
      const q = query(
        collection(firestore, 'users'),
        where('username', '==', username)
      );
      const querySnapshot = await getDocs(q);
      return querySnapshot.empty;
    } catch (error) {
      console.error('Error checking username availability:', error);
      return false;
    } finally {
      setCheckingUsername(false);
    }
  };

  const handleUsernameChange = async (text: string) => {
    setUsername(text);
    const validationError = validateUsername(text);
    
    if (validationError) {
      setUsernameError(validationError);
      return;
    }

    // Check availability after validation passes
    const isAvailable = await checkUsernameAvailability(text);
    if (!isAvailable) {
      setUsernameError('Username is already taken');
    } else {
      setUsernameError('');
    }
  };

  const handleCreateProfile = async () => {
    const validationError = validateUsername(username);
    if (validationError) {
      setUsernameError(validationError);
      return;
    }

    if (usernameError) {
      Alert.alert('Error', usernameError);
      return;
    }

    setLoading(true);
    try {
      const user = auth.currentUser;
      if (!user) {
        throw new Error('No authenticated user found');
      }

      // Double-check username availability
      const isAvailable = await checkUsernameAvailability(username);
      if (!isAvailable) {
        setUsernameError('Username is already taken');
        setLoading(false);
        return;
      }

      // Create user profile
      await setDoc(doc(firestore, 'users', user.uid), {
        uid: user.uid,
        username: username,
        email: user.email,
        createdAt: new Date().toISOString(),
      });

      Alert.alert('Success', 'Profile created successfully!');
    } catch (error: any) {
      Alert.alert('Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContainer: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
      paddingVertical: 40,
    },
    surface: {
      padding: 24,
      borderRadius: 16,
      elevation: 4,
    },
    title: {
      fontSize: 32,
      fontWeight: 'bold',
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 8,
    },
    subtitle: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 32,
      lineHeight: 24,
    },
    inputContainer: {
      marginBottom: 24,
    },
    textInput: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      marginBottom: 8,
    },
    helperText: {
      fontSize: 12,
      marginTop: 4,
    },
    createButton: {
      paddingVertical: 12,
      borderRadius: 12,
      marginTop: 16,
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
    },
    usernameContainer: {
      position: 'relative',
    },
    checkingIndicator: {
      position: 'absolute',
      right: 16,
      top: 20,
    },
  });

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.surface}>
          <Text style={styles.title}>Complete Setup</Text>
          <Text style={styles.subtitle}>
            Choose a unique username
          </Text>

          <View style={styles.inputContainer}>
            <View style={styles.usernameContainer}>
              <TextInput
                mode="outlined"
                label="Username"
                value={username}
                onChangeText={handleUsernameChange}
                style={styles.textInput}
                disabled={loading}
                error={!!usernameError}
                autoCapitalize="none"
                placeholder="Enter your username"
              />
              {checkingUsername && (
                <ActivityIndicator
                  size="small"
                  color={theme.colors.primary}
                  style={styles.checkingIndicator}
                />
              )}
            </View>
            
            <HelperText 
              type={usernameError ? 'error' : 'info'} 
              visible={!!usernameError || !usernameError && username.length > 0}
              style={styles.helperText}
            >
              {usernameError || 'Username can contain letters, numbers, and underscores'}
            </HelperText>
          </View>

          <Button
            mode="contained"
            onPress={handleCreateProfile}
            style={styles.createButton}
            disabled={loading || !!usernameError || !username || checkingUsername}
          >
            {loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="small" color={theme.colors.onPrimary} />
                <Text style={{ color: theme.colors.onPrimary }}>Creating profile...</Text>
              </View>
            ) : (
              'Complete Setup'
            )}
          </Button>
        </Surface>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default UserCreationScreen;

END OF UserCreationScreen.tsx>

ProfileScreen.tsx<

// src/screens/ProfileScreen.tsx

import React, { useState, useEffect } from 'react';
import { 
  View, 
  StyleSheet, 
  SafeAreaView, 
  ScrollView,
  RefreshControl 
} from 'react-native';
import { 
  Text, 
  Button, 
  useTheme, 
  Surface, 
  Divider,
  ActivityIndicator,
  Avatar,
  IconButton,
  ProgressBar
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { signOut } from 'firebase/auth';
import { doc, getDoc } from 'firebase/firestore';
import { auth, firestore } from '../utils/firebase';
import { getMonthString } from '../utils/rankingUtils';

interface UserStats {
  username: string;
  email: string;
  totalQuizzes: number;
  totalCorrectAnswers: number;
  stats?: {
    allTime?: {
      totalQuizzes: number;
      totalCorrectAnswers: number;
      averageScore: number;
    };
    categories?: {
      [key: string]: {
        totalQuizzes: number;
        totalCorrectAnswers: number;
        averageScore: number;
      };
    };
  };
  createdAt?: string;
}

const ProfileScreen: React.FC = () => {
  const theme = useTheme();
  const user = auth.currentUser;
  const [userStats, setUserStats] = useState<UserStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  useEffect(() => {
    fetchUserStats();
  }, []);

  const fetchUserStats = async () => {
    if (!user) return;

    try {
      const userDoc = await getDoc(doc(firestore, 'users', user.uid));
      if (userDoc.exists()) {
        setUserStats(userDoc.data() as UserStats);
      }
    } catch (error) {
      console.error('Error fetching user stats:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    fetchUserStats();
  };

  const handleSignOut = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.error('Sign out error:', error);
    }
  };

  const calculateOverallAverage = (): number => {
    if (!userStats || !userStats.totalQuizzes || userStats.totalQuizzes === 0) return 0;
    if (!userStats.totalCorrectAnswers) return 0;
    // Assuming 10 questions per quiz
    const totalPossibleAnswers = userStats.totalQuizzes * 10;
    return (userStats.totalCorrectAnswers / totalPossibleAnswers) * 100;
  };

  const getMembershipDuration = (): string => {
    if (!userStats?.createdAt) return 'New member';
    
    const createdDate = new Date(userStats.createdAt);
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - createdDate.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays < 7) return `${diffDays} days`;
    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks`;
    if (diffDays < 365) return `${Math.floor(diffDays / 30)} months`;
    return `${Math.floor(diffDays / 365)} years`;
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <ScrollView
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        contentContainerStyle={styles.scrollContent}
      >
        {/* Header Section */}
        <Surface style={styles.headerCard} elevation={2}>
          <Avatar.Text
            size={80}
            label={userStats?.username?.substring(0, 2).toUpperCase() || 'AN'}
            style={{ backgroundColor: theme.colors.primary }}
          />
          <Text style={styles.username}>{userStats?.username || 'Anonymous'}</Text>
          <Text style={styles.email}>{user?.email}</Text>
          <Text style={styles.memberDuration}>
            <MaterialCommunityIcons name="clock-outline" size={14} /> Member for {getMembershipDuration()}
          </Text>
        </Surface>

        {/* Quick Stats */}
        <View style={styles.statsGrid}>
          <Surface style={styles.statCard} elevation={1}>
            <MaterialCommunityIcons
              name="gamepad-variant"
              size={24}
              color={theme.colors.primary}
            />
            <Text style={styles.statValue}>{userStats?.totalQuizzes || 0}</Text>
            <Text style={styles.statLabel}>Quizzes Played</Text>
          </Surface>

          <Surface style={styles.statCard} elevation={1}>
            <MaterialCommunityIcons
              name="check-circle"
              size={24}
              color={theme.colors.primary}
            />
            <Text style={styles.statValue}>{userStats?.totalCorrectAnswers || 0}</Text>
            <Text style={styles.statLabel}>Correct Answers</Text>
          </Surface>

          <Surface style={styles.statCard} elevation={1}>
            <MaterialCommunityIcons
              name="percent"
              size={24}
              color={theme.colors.primary}
            />
            <Text style={styles.statValue}>{calculateOverallAverage().toFixed(1)}%</Text>
            <Text style={styles.statLabel}>Average Score</Text>
          </Surface>
        </View>

        {/* Performance Overview */}
        <Surface style={styles.performanceCard} elevation={1}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Performance Overview</Text>
            <MaterialCommunityIcons
              name="chart-line"
              size={20}
              color={theme.colors.primary}
            />
          </View>
          
          <View style={styles.performanceItem}>
            <Text style={styles.performanceLabel}>Overall Accuracy</Text>
            <Text style={styles.performanceValue}>{calculateOverallAverage().toFixed(1)}%</Text>
            <ProgressBar
              progress={calculateOverallAverage() / 100}
              color={theme.colors.primary}
              style={styles.progressBar}
            />
          </View>

          {/* Category Breakdown */}
          {userStats?.stats?.categories && Object.keys(userStats.stats.categories).length > 0 && (
            <>
              <Divider style={styles.divider} />
              <Text style={styles.subsectionTitle}>Category Performance</Text>
              {Object.entries(userStats.stats.categories)
                .sort((a, b) => b[1].totalQuizzes - a[1].totalQuizzes)
                .slice(0, 5)
                .map(([categoryId, stats]) => (
                  <View key={categoryId} style={styles.categoryItem}>
                    <Text style={styles.categoryName}>
                      {categoryId === 'all' ? 'All Anime' : `Category ${categoryId}`}
                    </Text>
                    <View style={styles.categoryStats}>
                      <Text style={styles.categoryQuizzes}>{stats.totalQuizzes} quizzes</Text>
  <Text style={styles.categoryScore}>
                        {stats.averageScore ? stats.averageScore.toFixed(1) : '0.0'}%
                      </Text>
                    </View>
                  </View>
                ))}
            </>
          )}
        </Surface>

        {/* Achievements Section (Placeholder) */}
        <Surface style={styles.achievementsCard} elevation={1}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Achievements</Text>
            <MaterialCommunityIcons
              name="trophy"
              size={20}
              color={theme.colors.primary}
            />
          </View>
          <Text style={styles.comingSoonText}>Coming Soon!</Text>
          <Text style={styles.comingSoonSubtext}>
            Unlock achievements by completing quizzes and climbing the rankings
          </Text>
        </Surface>

        {/* Sign Out Button */}
        <Button
          mode="contained"
          onPress={handleSignOut}
          style={styles.signOutButton}
          icon="logout"
        >
          Sign Out
        </Button>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollContent: {
    paddingBottom: 20,
  },
  headerCard: {
    margin: 16,
    padding: 24,
    borderRadius: 16,
    alignItems: 'center',
  },
  username: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 12,
  },
  email: {
    fontSize: 16,
    opacity: 0.7,
    marginTop: 4,
  },
  memberDuration: {
    fontSize: 14,
    opacity: 0.6,
    marginTop: 8,
    flexDirection: 'row',
    alignItems: 'center',
  },
  statsGrid: {
    flexDirection: 'row',
    paddingHorizontal: 16,
    gap: 8,
    marginBottom: 16,
  },
  statCard: {
    flex: 1,
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 8,
  },
  statLabel: {
    fontSize: 12,
    opacity: 0.7,
    marginTop: 4,
  },
  performanceCard: {
    margin: 16,
    padding: 16,
    borderRadius: 12,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
  },
  performanceItem: {
    marginBottom: 16,
  },
  performanceLabel: {
    fontSize: 14,
    opacity: 0.7,
    marginBottom: 4,
  },
  performanceValue: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  progressBar: {
    height: 8,
    borderRadius: 4,
  },
  divider: {
    marginVertical: 16,
  },
  subsectionTitle: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 12,
    opacity: 0.8,
  },
  categoryItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8,
  },
  categoryName: {
    fontSize: 14,
    flex: 1,
  },
  categoryStats: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 16,
  },
  categoryQuizzes: {
    fontSize: 12,
    opacity: 0.6,
  },
  categoryScore: {
    fontSize: 16,
    fontWeight: '600',
  },
  achievementsCard: {
    margin: 16,
    padding: 16,
    borderRadius: 12,
  },
  comingSoonText: {
    fontSize: 16,
    textAlign: 'center',
    opacity: 0.8,
    marginTop: 20,
  },
  comingSoonSubtext: {
    fontSize: 14,
    textAlign: 'center',
    opacity: 0.6,
    marginTop: 8,
    marginBottom: 12,
  },
  signOutButton: {
    marginHorizontal: 16,
    marginTop: 8,
    paddingVertical: 8,
    borderRadius: 8,
  },
});

export default ProfileScreen;

END OF ProfileScreen.tsx>

firebase.ts<

// src/utils/firebase.ts

import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth';
import Constants from 'expo-constants';

const firebaseConfig = {
  apiKey: Constants.expoConfig?.extra?.FIREBASE_API_KEY,
  authDomain: Constants.expoConfig?.extra?.FIREBASE_AUTH_DOMAIN,
  projectId: Constants.expoConfig?.extra?.FIREBASE_PROJECT_ID,
  storageBucket: Constants.expoConfig?.extra?.FIREBASE_STORAGE_BUCKET,
  messagingSenderId: Constants.expoConfig?.extra?.FIREBASE_MESSAGING_SENDER_ID,
  appId: Constants.expoConfig?.extra?.FIREBASE_APP_ID,
  measurementId: Constants.expoConfig?.extra?.FIREBASE_MEASUREMENT_ID
};

const app = initializeApp(firebaseConfig);
const firestore = getFirestore(app);
const auth = getAuth(app);

export { firestore, auth };

END OF firebase.ts>

quizUtils.ts<

// src/utils/quizUtils.ts

import { 
  collection, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs,
  doc,
  setDoc,
  getDoc,
  DocumentData
} from 'firebase/firestore';
import { firestore } from './firebase';

interface Question {
  id: string;
  question: string;
  options: string[];
  correctAnswer: number;
  animeId?: number;
  animeName?: string;
  random: number;
}

interface DailyQuestions {
  date: string;
  category: string;
  questions: Question[];
  generatedAt: Date;
}

/**
 * Get the current UTC date in YYYY-MM-DD format
 */
export const getUTCDateString = (): string => {
  const now = new Date();
  const year = now.getUTCFullYear();
  const month = String(now.getUTCMonth() + 1).padStart(2, '0');
  const day = String(now.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

/**
 * Generate a seed number from a date string and category
 */
const generateDailySeed = (dateString: string, category: string): number => {
  let hash = 0;
  const str = `${dateString}-${category}`;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash);
};

/**
 * Get daily questions for a specific category
 */
export const getDailyQuestions = async (
  animeId: number | null,
  questionCount: number = 10
): Promise<Question[]> => {
  const dateString = getUTCDateString();
  const category = animeId === null ? 'all' : animeId.toString();
  const dailyQuestionId = `${dateString}_${category}`;

  try {
    // First, check if we already have questions for today
    const dailyQuestionDoc = await getDoc(
      doc(firestore, 'dailyQuestions', dailyQuestionId)
    );

    if (dailyQuestionDoc.exists()) {
      const data = dailyQuestionDoc.data() as DailyQuestions;
      console.log(`Using cached questions for ${category} on ${dateString}`);
      return data.questions;
    }

    // If not, generate new questions for today
    console.log(`Generating new questions for ${category} on ${dateString}`);
    const seed = generateDailySeed(dateString, category);
    
    // Use modulo to create "buckets" for deterministic selection
    const bucketSize = 1000;
    const targetBucket = seed % bucketSize;

    // Fetch questions using the random field for efficient querying
    let questionsQuery;
    if (animeId === null) {
      // For "all" category, fetch from all questions
      questionsQuery = query(
        collection(firestore, 'questions'),
        where('random', '>=', targetBucket),
        where('random', '<', targetBucket + 100),
        orderBy('random'),
        limit(questionCount * 2) // Fetch extra in case we need them
      );
    } else {
      // For specific anime
      questionsQuery = query(
        collection(firestore, 'questions'),
        where('animeId', '==', animeId),
        where('random', '>=', targetBucket),
        where('random', '<', targetBucket + 100),
        orderBy('random'),
        limit(questionCount * 2)
      );
    }

    let snapshot = await getDocs(questionsQuery);
    let questions: Question[] = [];

    // If we didn't get enough questions in the target bucket, wrap around
    if (snapshot.size < questionCount) {
      if (animeId === null) {
        questionsQuery = query(
          collection(firestore, 'questions'),
          orderBy('random'),
          limit(questionCount * 3)
        );
      } else {
        questionsQuery = query(
          collection(firestore, 'questions'),
          where('animeId', '==', animeId),
          orderBy('random'),
          limit(questionCount * 3)
        );
      }
      snapshot = await getDocs(questionsQuery);
    }

    // Convert to Question array
    snapshot.forEach((doc) => {
      const data = doc.data();
      questions.push({
        id: doc.id,
        question: data.question,
        options: data.options,
        correctAnswer: data.correctAnswer,
        animeId: data.animeId,
        animeName: data.animeName,
        random: data.random,
      });
    });

    // Use the seed to deterministically select from available questions
    const selectedQuestions: Question[] = [];
    const availableIndices = questions.map((_, index) => index);
    
    for (let i = 0; i < Math.min(questionCount, questions.length); i++) {
      const seedForIndex = (seed + i) % availableIndices.length;
      const selectedIndex = availableIndices[seedForIndex];
      selectedQuestions.push(questions[selectedIndex]);
      availableIndices.splice(seedForIndex, 1);
    }

    // Cache the selected questions for today
    const dailyQuestionsData: DailyQuestions = {
      date: dateString,
      category,
      questions: selectedQuestions,
      generatedAt: new Date(),
    };

    await setDoc(
      doc(firestore, 'dailyQuestions', dailyQuestionId),
      dailyQuestionsData
    );

    return selectedQuestions;
  } catch (error) {
    console.error('Error fetching daily questions:', error);
    throw error;
  }
};

/**
 * Check if the user has already played today (based on UTC time)
 */
export const hasPlayedToday = async (
  userId: string,
  category: string
): Promise<boolean> => {
  const dateString = getUTCDateString();
  
  const attemptQuery = query(
    collection(firestore, 'dailyQuizzes'),
    where('userId', '==', userId),
    where('date', '==', dateString),
    where('category', '==', category)
  );

  const snapshot = await getDocs(attemptQuery);
  return !snapshot.empty;
};

/**
 * Get time until next UTC midnight
 */
export const getTimeUntilReset = (): { hours: number; minutes: number; seconds: number } => {
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);
  tomorrow.setUTCHours(0, 0, 0, 0);
  
  const diff = tomorrow.getTime() - now.getTime();
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  
  return { hours, minutes, seconds };
};

END OF quizUtils.ts>

rankingUtils.ts<

// src/utils/rankingUtils.ts

import { 
  collection, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs,
  doc,
  setDoc,
  getDoc,
  writeBatch,
  serverTimestamp,
  Timestamp
} from 'firebase/firestore';
import { firestore } from './firebase';

interface RankingDocument {
  period: 'daily' | 'monthly' | 'allTime';
  periodValue: string;
  category: string;
  userId: string;
  username: string;
  score: number;
  totalQuestions: number;
  averageScore: number;
  quizCount: number;
  lastUpdated: Date;
}

interface LeaderboardPlayer {
  userId: string;
  username: string;
  score: number;
  totalQuestions: number;
  averageScore: number;
  quizCount: number;
  rank: number;
}

interface LeaderboardCache {
  period: 'daily' | 'monthly' | 'allTime';
  periodValue: string;
  category: string;
  lastUpdated: Date;
  topPlayers: LeaderboardPlayer[];
  totalPlayers?: number;
}

/**
 * Get the current month in YYYY-MM format
 */
export const getMonthString = (date: Date = new Date()): string => {
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
};

/**
 * Update rankings after a quiz is completed
 */
export const updateRankings = async (
  userId: string,
  category: string,
  score: number,
  totalQuestions: number
) => {
  try {
    const batch = writeBatch(firestore);
    const now = new Date();
    const dailyKey = getUTCDateString();
    const monthlyKey = getMonthString(now);
    
    // Get user data
    const userRef = doc(firestore, 'users', userId);
    const userDoc = await getDoc(userRef);
    
    if (!userDoc.exists()) {
      throw new Error('User not found');
    }
    
    const userData = userDoc.data();
    const username = userData.username || 'Anonymous';
    const averageScore = (score / totalQuestions) * 100;
    
    // Update daily ranking
    const dailyRankingId = `daily_${dailyKey}_${category}_${userId}`;
    const dailyRankingRef = doc(firestore, 'rankings', dailyRankingId);
    
    batch.set(dailyRankingRef, {
      period: 'daily',
      periodValue: dailyKey,
      category,
      userId,
      username,
      score,
      totalQuestions,
      averageScore,
      quizCount: 1,
      lastUpdated: serverTimestamp()
    });
    
    // Update monthly ranking (accumulative)
    const monthlyRankingId = `monthly_${monthlyKey}_${category}_${userId}`;
    const monthlyRankingRef = doc(firestore, 'rankings', monthlyRankingId);
    const monthlyDoc = await getDoc(monthlyRankingRef);
    
    if (monthlyDoc.exists()) {
      const monthlyData = monthlyDoc.data();
      const newScore = monthlyData.score + score;
      const newTotalQuestions = monthlyData.totalQuestions + totalQuestions;
      const newQuizCount = monthlyData.quizCount + 1;
      
      batch.update(monthlyRankingRef, {
        score: newScore,
        totalQuestions: newTotalQuestions,
        averageScore: (newScore / newTotalQuestions) * 100,
        quizCount: newQuizCount,
        lastUpdated: serverTimestamp()
      });
    } else {
      batch.set(monthlyRankingRef, {
        period: 'monthly',
        periodValue: monthlyKey,
        category,
        userId,
        username,
        score,
        totalQuestions,
        averageScore,
        quizCount: 1,
        lastUpdated: serverTimestamp()
      });
    }
    
    // Update all-time ranking (accumulative)
    const allTimeRankingId = `allTime_all_${category}_${userId}`;
    const allTimeRankingRef = doc(firestore, 'rankings', allTimeRankingId);
    const allTimeDoc = await getDoc(allTimeRankingRef);
    
    if (allTimeDoc.exists()) {
      const allTimeData = allTimeDoc.data();
      const newScore = allTimeData.score + score;
      const newTotalQuestions = allTimeData.totalQuestions + totalQuestions;
      const newQuizCount = allTimeData.quizCount + 1;
      
      batch.update(allTimeRankingRef, {
        score: newScore,
        totalQuestions: newTotalQuestions,
        averageScore: (newScore / newTotalQuestions) * 100,
        quizCount: newQuizCount,
        lastUpdated: serverTimestamp()
      });
    } else {
      batch.set(allTimeRankingRef, {
        period: 'allTime',
        periodValue: 'all',
        category,
        userId,
        username,
        score,
        totalQuestions,
        averageScore,
        quizCount: 1,
        lastUpdated: serverTimestamp()
      });
    }
    
    // Update user stats
    const currentStats = userData.stats || {};
    const categoryStats = currentStats.categories || {};
    const currentCategoryStats = categoryStats[category] || { 
      totalQuizzes: 0, 
      totalCorrectAnswers: 0, 
      averageScore: 0 
    };
    
    const newCategoryQuizzes = currentCategoryStats.totalQuizzes + 1;
    const newCategoryCorrect = currentCategoryStats.totalCorrectAnswers + score;
    const newCategoryAverage = (newCategoryCorrect / (newCategoryQuizzes * totalQuestions)) * 100;
    
    batch.update(userRef, {
      [`stats.categories.${category}`]: {
        totalQuizzes: newCategoryQuizzes,
        totalCorrectAnswers: newCategoryCorrect,
        averageScore: newCategoryAverage
      },
      'stats.allTime.totalQuizzes': (currentStats.allTime?.totalQuizzes || 0) + 1,
      'stats.allTime.totalCorrectAnswers': (currentStats.allTime?.totalCorrectAnswers || 0) + score,
      'stats.allTime.lastUpdated': serverTimestamp()
    });
    
    await batch.commit();
    
    // Trigger leaderboard cache updates
    await Promise.all([
      updateLeaderboardCache('daily', dailyKey, category),
      updateLeaderboardCache('monthly', monthlyKey, category),
      updateLeaderboardCache('allTime', 'all', category)
    ]);
    
  } catch (error) {
    console.error('Error updating rankings:', error);
    throw error;
  }
};

/**
 * Update leaderboard cache for a specific period and category
 */
export const updateLeaderboardCache = async (
  period: 'daily' | 'monthly' | 'allTime',
  periodValue: string,
  category: string
) => {
  try {
    // Query top 100 players by score
    const rankingsQuery = query(
      collection(firestore, 'rankings'),
      where('period', '==', period),
      where('periodValue', '==', periodValue),
      where('category', '==', category),
      orderBy('score', 'desc'),
      orderBy('averageScore', 'desc'),
      limit(100)
    );
    
    const snapshot = await getDocs(rankingsQuery);
    
    const topPlayers: LeaderboardPlayer[] = snapshot.docs.map((doc, index) => {
      const data = doc.data();
      return {
        userId: data.userId,
        username: data.username,
        score: data.score,
        totalQuestions: data.totalQuestions,
        averageScore: data.averageScore,
        quizCount: data.quizCount,
        rank: index + 1
      };
    });
    
    // Count total players for this period/category
    const countQuery = query(
      collection(firestore, 'rankings'),
      where('period', '==', period),
      where('periodValue', '==', periodValue),
      where('category', '==', category)
    );
    
    const countSnapshot = await getDocs(countQuery);
    const totalPlayers = countSnapshot.size;
    
    // Update cache
    const cacheId = `${period}_${periodValue}_${category}`;
    await setDoc(doc(firestore, 'leaderboardCache', cacheId), {
      period,
      periodValue,
      category,
      lastUpdated: serverTimestamp(),
      topPlayers,
      totalPlayers
    });
    
  } catch (error) {
    console.error('Error updating leaderboard cache:', error);
  }
};

/**
 * Get leaderboard data from cache
 */
export const getLeaderboardData = async (
  period: 'daily' | 'monthly' | 'allTime',
  periodValue: string,
  category: string
): Promise<LeaderboardCache | null> => {
  try {
    const cacheId = `${period}_${periodValue}_${category}`;
    const cacheDoc = await getDoc(doc(firestore, 'leaderboardCache', cacheId));
    
    if (cacheDoc.exists()) {
      const data = cacheDoc.data();
      return {
        ...data,
        lastUpdated: data.lastUpdated?.toDate() || new Date()
      } as LeaderboardCache;
    }
    
    // If cache doesn't exist, try to create it
    await updateLeaderboardCache(period, periodValue, category);
    
    // Try to get it again
    const updatedCacheDoc = await getDoc(doc(firestore, 'leaderboardCache', cacheId));
    if (updatedCacheDoc.exists()) {
      const data = updatedCacheDoc.data();
      return {
        ...data,
        lastUpdated: data.lastUpdated?.toDate() || new Date()
      } as LeaderboardCache;
    }
    
    return null;
  } catch (error) {
    console.error('Error getting leaderboard data:', error);
    return null;
  }
};

/**
 * Get user's rank for a specific period and category
 */
export const getUserRank = async (
  userId: string,
  period: 'daily' | 'monthly' | 'allTime',
  periodValue: string,
  category: string
): Promise<{ rank: number; totalPlayers: number; score: number; averageScore: number } | null> => {
  try {
    // First check if user has a ranking document
    const rankingId = `${period}_${periodValue}_${category}_${userId}`;
    const userRankingDoc = await getDoc(doc(firestore, 'rankings', rankingId));
    
    if (!userRankingDoc.exists()) {
      return null;
    }
    
    const userData = userRankingDoc.data();
    
    // Count how many players have a higher score
    const betterPlayersQuery = query(
      collection(firestore, 'rankings'),
      where('period', '==', period),
      where('periodValue', '==', periodValue),
      where('category', '==', category),
      where('score', '>', userData.score)
    );
    
    const betterPlayersSnapshot = await getDocs(betterPlayersQuery);
    const rank = betterPlayersSnapshot.size + 1;
    
    // Get total players
    const allPlayersQuery = query(
      collection(firestore, 'rankings'),
      where('period', '==', period),
      where('periodValue', '==', periodValue),
      where('category', '==', category)
    );
    
    const allPlayersSnapshot = await getDocs(allPlayersQuery);
    const totalPlayers = allPlayersSnapshot.size;
    
    return {
      rank,
      totalPlayers,
      score: userData.score,
      averageScore: userData.averageScore
    };
  } catch (error) {
    console.error('Error getting user rank:', error);
    return null;
  }
};

/**
 * Get available categories from the anime collection
 */
export const getAvailableCategories = async (): Promise<Array<{ id: string; title: string }>> => {
  try {
    const categories = [{ id: 'all', title: 'All Anime' }];
    
    const animesSnapshot = await getDocs(collection(firestore, 'animes'));
    animesSnapshot.forEach((doc) => {
      const data = doc.data();
      if (data.id && data.title) {
        categories.push({
          id: data.id.toString(),
          title: data.title
        });
      }
    });
    
    // Sort by title, keeping "All Anime" first
    return [
      categories[0],
      ...categories.slice(1).sort((a, b) => a.title.localeCompare(b.title))
    ];
  } catch (error) {
    console.error('Error getting categories:', error);
    return [{ id: 'all', title: 'All Anime' }];
  }
};

// Import the getUTCDateString function from quizUtils
import { getUTCDateString } from './quizUtils';

END OF rankingUtils.ts>

theme.ts<

// src/themes/theme.ts

import { MD3DarkTheme, configureFonts } from 'react-native-paper';

const fontConfig = {
  displayLarge: {
    fontFamily: 'System',
    fontSize: 57,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 64,
  },
  displayMedium: {
    fontFamily: 'System',
    fontSize: 45,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 52,
  },
  displaySmall: {
    fontFamily: 'System',
    fontSize: 36,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 44,
  },
  headlineLarge: {
    fontFamily: 'System',
    fontSize: 32,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 40,
  },
  headlineMedium: {
    fontFamily: 'System',
    fontSize: 28,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 36,
  },
  headlineSmall: {
    fontFamily: 'System',
    fontSize: 24,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 32,
  },
  titleLarge: {
    fontFamily: 'System',
    fontSize: 22,
    fontWeight: '500' as const,
    letterSpacing: 0,
    lineHeight: 28,
  },
  titleMedium: {
    fontFamily: 'System',
    fontSize: 16,
    fontWeight: '500' as const,
    letterSpacing: 0.1,
    lineHeight: 24,
  },
  titleSmall: {
    fontFamily: 'System',
    fontSize: 14,
    fontWeight: '500' as const,
    letterSpacing: 0.1,
    lineHeight: 20,
  },
  labelLarge: {
    fontFamily: 'System',
    fontSize: 14,
    fontWeight: '500' as const,
    letterSpacing: 0.1,
    lineHeight: 20,
  },
  labelMedium: {
    fontFamily: 'System',
    fontSize: 12,
    fontWeight: '500' as const,
    letterSpacing: 0.5,
    lineHeight: 16,
  },
  labelSmall: {
    fontFamily: 'System',
    fontSize: 11,
    fontWeight: '500' as const,
    letterSpacing: 0.5,
    lineHeight: 16,
  },
  bodyLarge: {
    fontFamily: 'System',
    fontSize: 16,
    fontWeight: '400' as const,
    letterSpacing: 0.5,
    lineHeight: 24,
  },
  bodyMedium: {
    fontFamily: 'System',
    fontSize: 14,
    fontWeight: '400' as const,
    letterSpacing: 0.25,
    lineHeight: 20,
  },
  bodySmall: {
    fontFamily: 'System',
    fontSize: 12,
    fontWeight: '400' as const,
    letterSpacing: 0.4,
    lineHeight: 16,
  },
};

export const customDarkTheme = {
  ...MD3DarkTheme,
  fonts: configureFonts({ config: fontConfig }),
  colors: {
    ...MD3DarkTheme.colors,
    primary: '#6C5CE7',
    primaryContainer: '#4834D4',
    secondary: '#A29BFE',
    secondaryContainer: '#6C5CE7',
    tertiary: '#FD79A8',
    tertiaryContainer: '#E84393',
    surface: '#1E1E1E',
    surfaceVariant: '#2A2A2A',
    background: '#121212',
    error: '#FF6B6B',
    errorContainer: '#FF5252',
    onPrimary: '#FFFFFF',
    onPrimaryContainer: '#FFFFFF',
    onSecondary: '#FFFFFF',
    onSecondaryContainer: '#FFFFFF',
    onTertiary: '#FFFFFF',
    onTertiaryContainer: '#FFFFFF',
    onSurface: '#FFFFFF',
    onSurfaceVariant: '#CCCCCC',
    onBackground: '#FFFFFF',
    onError: '#FFFFFF',
    onErrorContainer: '#FFFFFF',
    outline: '#666666',
    outlineVariant: '#444444',
    shadow: '#000000',
    scrim: '#000000',
    inverseSurface: '#FFFFFF',
    inverseOnSurface: '#000000',
    inversePrimary: '#6C5CE7',
    elevation: {
      level0: 'transparent',
      level1: '#1E1E1E',
      level2: '#2A2A2A',
      level3: '#363636',
      level4: '#404040',
      level5: '#4A4A4A',
    },
    surfaceDisabled: '#1E1E1E',
    onSurfaceDisabled: '#666666',
    backdrop: 'rgba(0, 0, 0, 0.4)',
  },
};

export default customDarkTheme;

END OF theme.ts>

App.tsx<

// App.tsx

import React from 'react';
import { Provider as PaperProvider } from 'react-native-paper';
import { StatusBar } from 'expo-status-bar';
import AppNavigator from './src/navigation/AppNavigator';
import customDarkTheme from './src/themes/theme';

const App: React.FC = () => {
  return (
    <PaperProvider theme={customDarkTheme}>
      <StatusBar style="light" />
      <AppNavigator />
    </PaperProvider>
  );
};

export default App;

END OF App.tsx>

