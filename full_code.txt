AnimeCard.tsx<

// src/components/AnimeCard.tsx

import React from 'react';
import {
  StyleSheet,
  Image,
  View,
  Dimensions,
  TouchableOpacity,
} from 'react-native';
import {
  Card,
  Text,
  useTheme,
  IconButton,
} from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface AnimeCardProps {
  anime: {
    id: number | null;
    title: string;
    coverImage: string | { uri: string };
  };
  onPress: () => void;
  hasPlayedToday?: boolean;
  todayScore?: number;
  totalQuestions?: number;
}

const { width } = Dimensions.get('window');
const isSmallScreen = width < 380;
const cardWidth = isSmallScreen 
  ? (width - 32) / 2 - 8 
  : (width - 48) / 3 - 8;

const AnimeCard: React.FC<AnimeCardProps> = ({
  anime,
  onPress,
  hasPlayedToday,
  todayScore,
  totalQuestions = 10,
}) => {
  const theme = useTheme();

  const imageSource = typeof anime.coverImage === 'string' 
    ? { uri: anime.coverImage }
    : anime.coverImage;

  return (
    <TouchableOpacity onPress={onPress} activeOpacity={0.8}>
      <Card style={[styles.card, { width: cardWidth }]}>
        <View style={styles.imageContainer}>
          <Image
            source={imageSource}
            style={styles.image}
            resizeMode="cover"
          />
          
          {hasPlayedToday && (
            <View style={[styles.overlay, { backgroundColor: 'rgba(0,0,0,0.7)' }]}>
              <MaterialCommunityIcons
                name="check-circle"
                size={40}
                color={theme.colors.primary}
              />
              <Text style={styles.scoreText}>
                {todayScore}/{totalQuestions}
              </Text>
              <Text style={styles.playedText}>Played Today</Text>
            </View>
          )}
          
          {anime.id === null && (
            <View style={[styles.allBadge, { backgroundColor: theme.colors.primary }]}>
              <MaterialCommunityIcons name="infinity" size={20} color="white" />
            </View>
          )}
        </View>
        
        <Card.Content style={styles.content}>
          <Text 
            style={[styles.title, { color: theme.colors.onSurface }]} 
            numberOfLines={2}
            ellipsizeMode="tail"
          >
            {anime.title}
          </Text>
        </Card.Content>
      </Card>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    marginVertical: 4,
    elevation: 3,
    borderRadius: 12,
    overflow: 'hidden',
  },
  imageContainer: {
    position: 'relative',
    width: '100%',
    height: cardWidth * 1.4,
  },
  image: {
    width: '100%',
    height: '100%',
  },
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scoreText: {
    color: 'white',
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 8,
  },
  playedText: {
    color: 'white',
    fontSize: 12,
    marginTop: 4,
    opacity: 0.9,
  },
  allBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    borderRadius: 20,
    padding: 8,
  },
  content: {
    paddingVertical: 12,
    paddingHorizontal: 8,
    minHeight: 60,
    justifyContent: 'center',
  },
  title: {
    fontSize: isSmallScreen ? 13 : 14,
    fontWeight: '600',
    textAlign: 'center',
    lineHeight: 18,
  },
});

export default AnimeCard;

END OF AnimeCard.tsx>

DailyQuizStatus.tsx<

// src/components/DailyQuizStatus.tsx

import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Surface, Text, useTheme, ProgressBar } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface DailyAttempt {
  category: string;
  score: number;
  totalQuestions: number;
}

interface DailyQuizStatusProps {
  attempts: DailyAttempt[];
  timeUntilReset?: {
    hours: number;
    minutes: number;
    seconds: number;
  };
}

const DailyQuizStatus: React.FC<DailyQuizStatusProps> = ({ attempts, timeUntilReset }) => {
  const theme = useTheme();

  if (attempts.length === 0 && !timeUntilReset) {
    return null;
  }

  const totalScore = attempts.reduce((sum, attempt) => sum + attempt.score, 0);
  const totalPossible = attempts.reduce((sum, attempt) => sum + attempt.totalQuestions, 0);
  const percentage = totalPossible > 0 ? totalScore / totalPossible : 0;

  return (
    <Surface style={styles.container} elevation={1}>
      <View style={styles.header}>
        <MaterialCommunityIcons
          name="calendar-today"
          size={20}
          color={theme.colors.primary}
        />
        <Text style={styles.title}>Today's Progress</Text>
      </View>
      
      {attempts.length > 0 && (
        <>
          <View style={styles.content}>
            <Text style={styles.scoreText}>
              {totalScore} / {totalPossible} correct
            </Text>
            <Text style={styles.categoryText}>
              {attempts.length} quiz{attempts.length !== 1 ? 'zes' : ''} completed
            </Text>
          </View>
          
          <ProgressBar
            progress={percentage}
            color={theme.colors.primary}
            style={styles.progressBar}
          />
        </>
      )}
      
      {timeUntilReset && (
        <View style={styles.resetTimer}>
          <MaterialCommunityIcons
            name="clock-outline"
            size={16}
            color={theme.colors.onSurfaceVariant}
          />
          <Text style={styles.resetText}>
            Resets in {timeUntilReset.hours}h {timeUntilReset.minutes}m {timeUntilReset.seconds}s
          </Text>
        </View>
      )}
    </Surface>
  );
};

const styles = StyleSheet.create({
  container: {
    margin: 16,
    padding: 16,
    borderRadius: 12,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    marginLeft: 8,
  },
  content: {
    marginBottom: 12,
  },
  scoreText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  categoryText: {
    fontSize: 14,
    opacity: 0.7,
  },
  progressBar: {
    height: 8,
    borderRadius: 4,
  },
  resetTimer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 12,
    paddingTop: 12,
    borderTopWidth: 1,
    borderTopColor: 'rgba(255,255,255,0.1)',
  },
  resetText: {
    fontSize: 14,
    marginLeft: 6,
    opacity: 0.7,
  },
});

export default DailyQuizStatus;

END OF DailyQuizStatus.tsx>

AppNavigator.tsx<

// src/navigation/AppNavigator.tsx

import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { ActivityIndicator, View, StyleSheet } from 'react-native';
import { useTheme } from 'react-native-paper';
import { onAuthStateChanged, User } from 'firebase/auth';
import { doc, onSnapshot } from 'firebase/firestore';
import { auth, firestore } from '../utils/firebase';

// Import screens
import LoginScreen from '../screens/LoginScreen';
import RegisterScreen from '../screens/RegisterScreen';
import UserCreationScreen from '../screens/UserCreationScreen';
import MainTabNavigator from './MainTabNavigator';

export type RootStackParamList = {
  Login: undefined;
  Register: undefined;
  UserCreation: undefined;
  MainTabs: undefined;
};

const Stack = createStackNavigator<RootStackParamList>();

const AppNavigator: React.FC = () => {
  const theme = useTheme();
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<User | null>(null);
  const [hasProfile, setHasProfile] = useState(false);

  useEffect(() => {
    let profileUnsubscribe: (() => void) | null = null;

    const authUnsubscribe = onAuthStateChanged(auth, (currentUser) => {
      if (currentUser) {
        setUser(currentUser);
        
        // Clean up previous profile listener
        if (profileUnsubscribe) {
          profileUnsubscribe();
        }
        
        // Listen for real-time updates to user profile
        const userDocRef = doc(firestore, 'users', currentUser.uid);
        profileUnsubscribe = onSnapshot(
          userDocRef,
          (docSnap) => {
            setHasProfile(docSnap.exists());
            setLoading(false);
          },
          (error) => {
            console.error('Error listening to user profile:', error);
            setHasProfile(false);
            setLoading(false);
          }
        );
      } else {
        setUser(null);
        setHasProfile(false);
        setLoading(false);
        
        // Clean up profile listener when user signs out
        if (profileUnsubscribe) {
          profileUnsubscribe();
          profileUnsubscribe = null;
        }
      }
    });

    return () => {
      authUnsubscribe();
      if (profileUnsubscribe) {
        profileUnsubscribe();
      }
    };
  }, []);

  if (loading) {
    return (
      <View style={[styles.loadingContainer, { backgroundColor: theme.colors.background }]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <Stack.Navigator
        screenOptions={{
          headerShown: false,
          cardStyle: { backgroundColor: theme.colors.background },
        }}
      >
        {user ? (
          hasProfile ? (
            <Stack.Screen name="MainTabs" component={MainTabNavigator} />
          ) : (
            <Stack.Screen name="UserCreation" component={UserCreationScreen} />
          )
        ) : (
          <>
            <Stack.Screen name="Login" component={LoginScreen} />
            <Stack.Screen name="Register" component={RegisterScreen} />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default AppNavigator;

END OF AppNavigator.tsx>

MainTabNavigator.tsx<

// src/navigation/MainTabNavigator.tsx

import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useTheme } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';

// Import screens
import PlayNavigator from './PlayNavigator';
import RankingsScreen from '../screens/RankingsScreen';
import ProfileScreen from '../screens/ProfileScreen';

export type MainTabParamList = {
  Play: undefined;
  Rankings: undefined;
  Profile: undefined;
};

const Tab = createBottomTabNavigator<MainTabParamList>();

const MainTabNavigator: React.FC = () => {
  const theme = useTheme();

  return (
    <Tab.Navigator
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.onSurfaceVariant,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.outline,
          borderTopWidth: 1,
          height: 60,
          paddingBottom: 8,
          paddingTop: 8,
        },
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
      }}
    >
      <Tab.Screen
        name="Play"
        component={PlayNavigator}
        options={{
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="gamepad-variant" size={size} color={color} />
          ),
        }}
      />
      <Tab.Screen
        name="Rankings"
        component={RankingsScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="trophy" size={size} color={color} />
          ),
        }}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="account" size={size} color={color} />
          ),
        }}
      />
    </Tab.Navigator>
  );
};

export default MainTabNavigator;

END OF MainTabNavigator.tsx>

PlayNavigator.tsx<

// src/navigation/PlayNavigator.tsx

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import PlayScreen from '../screens/PlayScreen';
import QuizScreen from '../screens/QuizScreen';

export type PlayStackParamList = {
  PlayHome: {
    refresh?: boolean;
    completedCategory?: string;
    score?: number;
    totalQuestions?: number;
  } | undefined;
  Quiz: {
    animeId: number | null;
    animeName: string;
  };
};

const Stack = createStackNavigator<PlayStackParamList>();

const PlayNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="PlayHome" component={PlayScreen} />
      <Stack.Screen name="Quiz" component={QuizScreen} />
    </Stack.Navigator>
  );
};

export default PlayNavigator;

END OF PlayNavigator.tsx>

types.ts<

// src/navigation/types.ts

export type RootStackParamList = {
  Login: undefined;
  Register: undefined;
  UserCreation: undefined;
  MainTabs: undefined;
};

export type MainTabParamList = {
  Play: undefined;
  Rankings: undefined;
  Profile: undefined;
};

export type PlayStackParamList = {
  PlayHome: undefined;
  Quiz: {
    animeId: number | null;
    animeName: string;
  };
};

END OF types.ts>

PlayScreen.tsx<

// src/screens/PlayScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  FlatList,
  SafeAreaView,
  Dimensions,
  RefreshControl,
} from 'react-native';
import {
  Text,
  Surface,
  useTheme,
  ActivityIndicator,
  Snackbar,
} from 'react-native-paper';
import { collection, getDocs, query, where, doc, getDoc } from 'firebase/firestore';
import { firestore, auth } from '../utils/firebase';
import { useNavigation, useRoute, useFocusEffect } from '@react-navigation/native';
import { StackNavigationProp, StackScreenProps } from '@react-navigation/stack';
import { PlayStackParamList } from '../navigation/PlayNavigator';
import AnimeCard from '../components/AnimeCard';
import DailyQuizStatus from '../components/DailyQuizStatus';
import { getUTCDateString, getTimeUntilReset } from '../utils/quizUtils';

type PlayScreenNavigationProp = StackNavigationProp<PlayStackParamList, 'PlayHome'>;

interface AnimeItem {
  id: number | null;
  title: string;
  coverImage: string | { uri: string };
  popularity?: number;
  hasPlayedToday?: boolean;
  todayScore?: number;
}

interface DailyAttempt {
  userId: string;
  date: string;
  category: string;
  score: number;
  totalQuestions: number;
  completedAt: Date;
}

const { width } = Dimensions.get('window');
const isSmallScreen = width < 380;

type PlayScreenProps = StackScreenProps<PlayStackParamList, 'PlayHome'>;

const PlayScreen: React.FC<PlayScreenProps> = ({ route }) => {
  const theme = useTheme();
  const navigation = useNavigation<PlayScreenNavigationProp>();
  const [animeList, setAnimeList] = useState<AnimeItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dailyAttempts, setDailyAttempts] = useState<Record<string, DailyAttempt>>({});
  const [timeUntilReset, setTimeUntilReset] = useState(getTimeUntilReset());
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  // Handle navigation params and refresh
  useFocusEffect(
    React.useCallback(() => {
      if (route.params?.refresh) {
        checkDailyAttempts();
        if (route.params.completedCategory && route.params.score !== undefined) {
          setSuccessMessage(`Quiz completed! Score: ${route.params.score}/${route.params.totalQuestions || 10}`);
          setTimeout(() => setSuccessMessage(null), 3000);
        }
        // Clear params to prevent showing message again
        navigation.setParams({ 
          refresh: undefined, 
          completedCategory: undefined, 
          score: undefined,
          totalQuestions: undefined 
        } as any);
      }
    }, [route.params])
  );

  // Update timer every second
  useEffect(() => {
    const interval = setInterval(() => {
      setTimeUntilReset(getTimeUntilReset());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  const checkDailyAttempts = async () => {
    try {
      const user = auth.currentUser;
      if (!user) return;

      const todayDate = getUTCDateString();
      const attemptsQuery = query(
        collection(firestore, 'dailyQuizzes'),
        where('userId', '==', user.uid),
        where('date', '==', todayDate)
      );

      const snapshot = await getDocs(attemptsQuery);
      const attempts: Record<string, DailyAttempt> = {};

      snapshot.forEach((doc) => {
        const data = doc.data() as DailyAttempt;
        attempts[data.category] = data;
      });

      setDailyAttempts(attempts);
    } catch (error) {
      console.error('Error checking daily attempts:', error);
    }
  };

  const fetchAnimes = async () => {
    try {
      // First add the "All" category
      const allCategory: AnimeItem = {
        id: null,
        title: 'All Anime',
        coverImage: 'https://via.placeholder.com/300x450/6C5CE7/FFFFFF?text=ALL+ANIME',
      };

      // Fetch anime from Firestore
      const animesSnapshot = await getDocs(collection(firestore, 'animes'));
      const animes: AnimeItem[] = [allCategory];

      animesSnapshot.forEach((doc) => {
        const data = doc.data();
        if (data.id && data.title && data.coverImage) {
          animes.push({
            id: data.id,
            title: data.title,
            coverImage: data.coverImage,
            popularity: data.popularity || 0,
          });
        }
      });

      // Sort by popularity (keeping "All" first)
      const sortedAnimes = [
        allCategory,
        ...animes.slice(1).sort((a, b) => (b.popularity || 0) - (a.popularity || 0)),
      ];

      setAnimeList(sortedAnimes);
      setError(null);
    } catch (error) {
      console.error('Error fetching anime:', error);
      setError('Failed to load anime. Please try again.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    fetchAnimes();
    checkDailyAttempts();
  }, []);

  const handleRefresh = async () => {
    setRefreshing(true);
    await Promise.all([fetchAnimes(), checkDailyAttempts()]);
  };

  const handleAnimePress = (animeId: number | null, animeName: string) => {
    const category = animeId === null ? 'all' : animeId.toString();
    const attempt = dailyAttempts[category];

    if (attempt) {
      // Show score if already played today
      setError(`You already played ${animeName} today! Score: ${attempt.score}/${attempt.totalQuestions}`);
      return;
    }

    navigation.navigate('Quiz', {
      animeId,
      animeName,
    });
  };

  const renderAnimeCard = ({ item }: { item: AnimeItem }) => {
    const category = item.id === null ? 'all' : item.id.toString();
    const attempt = dailyAttempts[category];

    return (
      <View style={styles.cardWrapper}>
        <AnimeCard
          anime={item}
          onPress={() => handleAnimePress(item.id, item.title)}
          hasPlayedToday={!!attempt}
          todayScore={attempt?.score}
          totalQuestions={attempt?.totalQuestions}
        />
      </View>
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading anime...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <Surface style={styles.header} elevation={2}>
        <Text style={styles.title}>Anime Quiz</Text>
        <Text style={styles.subtitle}>Choose an anime to start your daily quiz</Text>
      </Surface>

      <DailyQuizStatus 
        attempts={Object.values(dailyAttempts)} 
        timeUntilReset={timeUntilReset}
      />

      <FlatList
        data={animeList}
        renderItem={renderAnimeCard}
        keyExtractor={(item) => item.id?.toString() || 'all'}
        numColumns={isSmallScreen ? 2 : 3}
        columnWrapperStyle={isSmallScreen ? styles.row : styles.rowLarge}
        contentContainerStyle={styles.listContainer}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        ListEmptyComponent={
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>No anime available</Text>
          </View>
        }
      />

      <Snackbar
        visible={!!error}
        onDismiss={() => setError(null)}
        duration={3000}
        style={{ backgroundColor: theme.colors.error }}
      >
        {error}
      </Snackbar>

      <Snackbar
        visible={!!successMessage}
        onDismiss={() => setSuccessMessage(null)}
        duration={3000}
        style={{ backgroundColor: theme.colors.primary }}
      >
        {successMessage}
      </Snackbar>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 12,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 4,
  },
  subtitle: {
    fontSize: 14,
    textAlign: 'center',
    opacity: 0.8,
  },
  listContainer: {
    paddingHorizontal: 8,
    paddingBottom: 20,
  },
  row: {
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  rowLarge: {
    justifyContent: 'space-between',
    paddingHorizontal: 8,
  },
  cardWrapper: {
    flex: 1,
    padding: 4,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    fontSize: 16,
    opacity: 0.6,
  },
});

export default PlayScreen;

END OF PlayScreen.tsx>

QuizScreen.tsx<

// src/screens/QuizScreen.tsx

import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Dimensions,
  BackHandler,
} from 'react-native';
import {
  Text,
  Button,
  Surface,
  useTheme,
  ActivityIndicator,
  ProgressBar,
  Dialog,
  Portal,
  IconButton,
} from 'react-native-paper';
import { useRoute, useNavigation, RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { PlayStackParamList } from '../navigation/PlayNavigator';
import { collection, query, where, getDocs, addDoc, doc, updateDoc, increment } from 'firebase/firestore';
import { firestore, auth } from '../utils/firebase';
import { getDailyQuestions, getUTCDateString } from '../utils/quizUtils';

type QuizScreenRouteProp = RouteProp<PlayStackParamList, 'Quiz'>;
type QuizScreenNavigationProp = StackNavigationProp<PlayStackParamList, 'Quiz'>;

interface Question {
  id: string;
  question: string;
  options: string[];
  correctAnswer: number;
  animeId?: number;
  animeName?: string;
}

interface Answer {
  questionId: string;
  selectedOption: number;
  isCorrect: boolean;
}

const { width, height } = Dimensions.get('window');
const isSmallScreen = width < 380;

const QuizScreen: React.FC = () => {
  const theme = useTheme();
  const route = useRoute<QuizScreenRouteProp>();
  const navigation = useNavigation<QuizScreenNavigationProp>();
  const { animeId, animeName } = route.params;

  // State declarations
  const [questions, setQuestions] = useState<Question[]>([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [answers, setAnswers] = useState<Answer[]>([]);
  const [selectedOption, setSelectedOption] = useState<number | null>(null);
  const [showFeedback, setShowFeedback] = useState(false);
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [showExitDialog, setShowExitDialog] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchQuestions();

    // Handle hardware back button
    const backHandler = BackHandler.addEventListener('hardwareBackPress', () => {
      if (!showResults) {
        setShowExitDialog(true);
        return true;
      }
      return false;
    });

    return () => backHandler.remove();
  }, [showResults]);

  const fetchQuestions = async () => {
    try {
      setLoading(true);
      
      // Use the new getDailyQuestions utility for consistent daily questions
      const dailyQuestions = await getDailyQuestions(animeId, 10);

      if (dailyQuestions.length === 0) {
        setError('No questions available for this category');
        setLoading(false);
        return;
      }

      setQuestions(dailyQuestions);
      setLoading(false);
    } catch (error) {
      console.error('Error fetching questions:', error);
      setError('Failed to load questions. Please try again.');
      setLoading(false);
    }
  };

  const handleSelectOption = (optionIndex: number) => {
    if (selectedOption !== null || showFeedback) return;

    setSelectedOption(optionIndex);
    setShowFeedback(true);

    const currentQuestion = questions[currentQuestionIndex];
    const isCorrect = optionIndex === currentQuestion.correctAnswer;

    // Record the answer
    const newAnswer: Answer = {
      questionId: currentQuestion.id,
      selectedOption: optionIndex,
      isCorrect,
    };

    const updatedAnswers = [...answers, newAnswer];
    setAnswers(updatedAnswers);

    // Auto-advance after showing feedback
    setTimeout(() => {
      if (currentQuestionIndex < questions.length - 1) {
        setCurrentQuestionIndex(currentQuestionIndex + 1);
        setSelectedOption(null);
        setShowFeedback(false);
      } else {
        // Last question - submit quiz
        submitQuiz(updatedAnswers);
      }
    }, 1500); // Show feedback for 1.5 seconds
  };

  const submitQuiz = async (finalAnswers: Answer[]) => {
    setSubmitting(true);
    try {
      const user = auth.currentUser;
      if (!user) throw new Error('User not authenticated');

      const score = finalAnswers.filter(a => a.isCorrect).length;
      
      const category = animeId === null ? 'all' : animeId.toString();
      const todayDate = getUTCDateString();

      // Save quiz attempt
      await addDoc(collection(firestore, 'dailyQuizzes'), {
        userId: user.uid,
        date: todayDate,
        category,
        animeName,
        score,
        totalQuestions: questions.length,
        completedAt: new Date(),
        answers: finalAnswers,
      });

      // Update user statistics
      const userRef = doc(firestore, 'users', user.uid);
      await updateDoc(userRef, {
        totalQuizzes: increment(1),
        totalCorrectAnswers: increment(score),
        [`categoryScores.${category}`]: increment(score),
      });

      setShowResults(true);
      
    } catch (error) {
      console.error('Error submitting quiz:', error);
      setError('Failed to submit quiz. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const handleExit = () => {
    setShowExitDialog(false);
    navigation.goBack();
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading questions...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>{error}</Text>
        <Button mode="contained" onPress={() => navigation.goBack()}>
          Go Back
        </Button>
      </View>
    );
  }

  if (showResults) {
    const score = answers.filter(a => a.isCorrect).length;

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
        <View style={styles.resultsWrapper}>
          <Surface style={styles.resultsContainer} elevation={2}>
            <Text style={styles.resultTitle}>Quiz Complete!</Text>
            <Text style={styles.categoryText}>{animeName}</Text>
            
            <View style={styles.scoreCircle}>
              <Text style={styles.scoreNumber}>{score}</Text>
              <Text style={styles.scoreDivider}>/</Text>
              <Text style={styles.scoreTotal}>10</Text>
            </View>
            
            <Button
              mode="contained"
              onPress={() => {
                const score = answers.filter(a => a.isCorrect).length;
                const category = animeId === null ? 'all' : animeId.toString();
                navigation.navigate('PlayHome', { 
                  refresh: true,
                  completedCategory: category,
                  score: score,
                  totalQuestions: 10
                });
              }}
              style={styles.finishButton}
            >
              Finish
            </Button>
          </Surface>
        </View>
      </SafeAreaView>
    );
  }

  const currentQuestion = questions[currentQuestionIndex];
  const progress = (currentQuestionIndex + 1) / questions.length;

  if (submitting) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Submitting quiz...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <View style={styles.header}>
        <IconButton
          icon="arrow-left"
          size={24}
          onPress={() => setShowExitDialog(true)}
        />
        <Text style={styles.questionCounter}>
          Question {currentQuestionIndex + 1} of {questions.length}
        </Text>
        <View style={{ width: 48 }} />
      </View>

      <ProgressBar progress={progress} color={theme.colors.primary} style={styles.mainProgressBar} />

      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.questionCard} elevation={2}>
          <Text style={[styles.questionText, isSmallScreen && styles.questionTextSmall]}>
            {currentQuestion.question}
          </Text>
        </Surface>

        <View style={styles.optionsContainer}>
          {currentQuestion.options.map((option, index) => {
            const isSelected = selectedOption === index;
            const isCorrect = index === currentQuestion.correctAnswer;
            const showCorrect = showFeedback && isCorrect;
            const showIncorrect = showFeedback && isSelected && !isCorrect;

            return (
              <Surface
                key={index}
                style={[
                  styles.optionCard,
                  showCorrect && styles.correctOption,
                  showIncorrect && styles.incorrectOption,
                ]}
                elevation={1}
              >
                <Button
                  mode="text"
                  onPress={() => handleSelectOption(index)}
                  style={styles.optionButton}
                  labelStyle={[
                    styles.optionText,
                    (showCorrect || showIncorrect) && styles.feedbackOptionText,
                    isSmallScreen && styles.optionTextSmall,
                  ]}
                  contentStyle={styles.optionContent}
                  disabled={showFeedback || submitting}
                >
                  {String.fromCharCode(65 + index)}. {option}
                </Button>
              </Surface>
            );
          })}
        </View>
      </ScrollView>

      <Portal>
        <Dialog visible={showExitDialog} onDismiss={() => setShowExitDialog(false)}>
          <Dialog.Title>Exit Quiz?</Dialog.Title>
          <Dialog.Content>
            <Text>Are you sure you want to exit? Your progress will be lost.</Text>
          </Dialog.Content>
          <Dialog.Actions>
            <Button onPress={() => setShowExitDialog(false)}>Cancel</Button>
            <Button onPress={handleExit}>Exit</Button>
          </Dialog.Actions>
        </Dialog>
      </Portal>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    marginBottom: 20,
    textAlign: 'center',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 4,
    paddingVertical: 8,
  },
  questionCounter: {
    fontSize: 16,
    fontWeight: '600',
  },
  mainProgressBar: {
    height: 6,
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 3,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 16,
    paddingBottom: 20,
  },
  questionCard: {
    padding: 20,
    borderRadius: 12,
    marginBottom: 24,
    minHeight: 120,
    justifyContent: 'center',
  },
  questionText: {
    fontSize: 18,
    lineHeight: 26,
    fontWeight: '500',
  },
  questionTextSmall: {
    fontSize: 16,
    lineHeight: 24,
  },
  optionsContainer: {
    gap: 12,
  },
  optionCard: {
    borderRadius: 12,
    overflow: 'hidden',
    borderWidth: 2,
    borderColor: 'transparent',
  },
  correctOption: {
    borderColor: '#4CAF50',
    backgroundColor: 'rgba(76, 175, 80, 0.1)',
  },
  incorrectOption: {
    borderColor: '#F44336',
    backgroundColor: 'rgba(244, 67, 54, 0.1)',
  },
  optionButton: {
    paddingVertical: 8,
    paddingHorizontal: 0,
  },
  optionContent: {
    height: 'auto',
    minHeight: 60,
    justifyContent: 'flex-start',
    paddingHorizontal: 16,
  },
  optionText: {
    fontSize: 16,
    textAlign: 'left',
    flex: 1,
    lineHeight: 22,
  },
  optionTextSmall: {
    fontSize: 14,
    lineHeight: 20,
  },
  feedbackOptionText: {
    fontWeight: '600',
  },
  resultsWrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  resultsContainer: {
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    width: '100%',
    maxWidth: 320,
  },
  resultTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  categoryText: {
    fontSize: 18,
    opacity: 0.8,
    marginBottom: 24,
  },
  scoreCircle: {
    flexDirection: 'row',
    alignItems: 'baseline',
    marginBottom: 8,
  },
  scoreNumber: {
    fontSize: 48,
    fontWeight: 'bold',
    color: '#6C5CE7', // Primary color
  },
  scoreDivider: {
    fontSize: 36,
    marginHorizontal: 4,
    opacity: 0.6,
  },
  scoreTotal: {
    fontSize: 36,
    opacity: 0.8,
  },
  finishButton: {
    paddingHorizontal: 32,
    paddingVertical: 8,
    borderRadius: 8,
    marginTop: 24,
  },
});

export default QuizScreen;

END OF QuizScreen.tsx>

RankingsScreen.tsx<

// src/screens/RankingsScreen.tsx

import React from 'react';
import { View, StyleSheet, SafeAreaView } from 'react-native';
import { Text, useTheme } from 'react-native-paper';

const RankingsScreen: React.FC = () => {
  const theme = useTheme();

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <View style={styles.content}>
        <Text style={[styles.title, { color: theme.colors.primary }]}>Rankings</Text>
        <Text style={[styles.subtitle, { color: theme.colors.onSurfaceVariant }]}>Coming Soon</Text>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    opacity: 0.6,
  },
});

export default RankingsScreen;

END OF RankingsScreen.tsx>

LoginScreen.tsx<

// src/screens/LoginScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import {
  Button,
  Text,
  TextInput,
  Surface,
  useTheme,
  IconButton,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { signInWithEmailAndPassword } from 'firebase/auth';
import { auth } from '../utils/firebase';

type LoginScreenProps = {
  navigation: any;
};

const LoginScreen: React.FC<LoginScreenProps> = ({ navigation }) => {
  const theme = useTheme();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [showEmailLogin, setShowEmailLogin] = useState(false);

  const handleEmailLogin = async () => {
    if (!email || !password) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    setLoading(true);
    try {
      await signInWithEmailAndPassword(auth, email, password);
      // Navigation will be handled by the auth state listener
    } catch (error: any) {
      Alert.alert('Login Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleLogin = async () => {
    Alert.alert('Coming Soon', 'Google sign-in will be implemented soon!');
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContainer: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
      paddingVertical: 40,
    },
    surface: {
      padding: 24,
      borderRadius: 16,
      marginBottom: 24,
      elevation: 4,
    },
    title: {
      fontSize: 32,
      fontWeight: 'bold',
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 8,
    },
    subtitle: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 32,
    },
    socialButtonsContainer: {
      gap: 16,
      marginBottom: 24,
    },
    socialButton: {
      paddingVertical: 12,
      borderRadius: 12,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    socialButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 12,
    },
    socialButtonText: {
      fontSize: 16,
      fontWeight: '500',
    },
    dividerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: 24,
      gap: 16,
    },
    dividerLine: {
      flex: 1,
      height: 1,
      backgroundColor: theme.colors.outline,
    },
    dividerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emailContainer: {
      gap: 16,
    },
    textInput: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
    },
    passwordContainer: {
      position: 'relative',
    },
    loginButton: {
      paddingVertical: 12,
      borderRadius: 12,
      marginTop: 8,
    },
    backButton: {
      alignSelf: 'center',
      marginTop: 16,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginTop: 24,
      gap: 4,
    },
    footerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    registerLink: {
      fontSize: 14,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
    },
  });

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.surface}>
          <Text style={styles.title}>Welcome Back</Text>
          <Text style={styles.subtitle}>Sign in to your account</Text>

          {!showEmailLogin ? (
            <>
              <View style={styles.socialButtonsContainer}>
                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={handleGoogleLogin}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Google</Text>
                  </View>
                </Button>

                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={() => setShowEmailLogin(true)}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Email</Text>
                  </View>
                </Button>
              </View>
            </>
          ) : (
            <>
              <View style={styles.dividerContainer}>
                <View style={styles.dividerLine} />
                <Text style={styles.dividerText}>Email Login</Text>
                <View style={styles.dividerLine} />
              </View>

              <View style={styles.emailContainer}>
                <TextInput
                  mode="outlined"
                  label="Email"
                  value={email}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                  style={styles.textInput}
                  disabled={loading}
                />

                <View style={styles.passwordContainer}>
                  <TextInput
                    mode="outlined"
                    label="Password"
                    value={password}
                    onChangeText={setPassword}
                    secureTextEntry={!showPassword}
                    style={styles.textInput}
                    disabled={loading}
                    right={
                      <TextInput.Icon
                        icon={showPassword ? 'eye-off' : 'eye'}
                        onPress={() => setShowPassword(!showPassword)}
                      />
                    }
                  />
                </View>

                <Button
                  mode="contained"
                  onPress={handleEmailLogin}
                  style={styles.loginButton}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.colors.onPrimary} />
                      <Text style={{ color: theme.colors.onPrimary }}>Signing in...</Text>
                    </View>
                  ) : (
                    'Sign In'
                  )}
                </Button>

                <Button
                  mode="text"
                  onPress={() => setShowEmailLogin(false)}
                  style={styles.backButton}
                  disabled={loading}
                >
                  Back to options
                </Button>
              </View>
            </>
          )}

          <View style={styles.footer}>
            <Text style={styles.footerText}>Don't have an account?</Text>
            <Button
              mode="text"
              onPress={() => navigation.navigate('Register')}
              disabled={loading}
            >
              <Text style={styles.registerLink}>Sign up</Text>
            </Button>
          </View>
        </Surface>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default LoginScreen;

END OF LoginScreen.tsx>

RegisterScreen.tsx<

// src/screens/RegisterScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import {
  Button,
  Text,
  TextInput,
  Surface,
  useTheme,
  IconButton,
  Divider,
  ActivityIndicator,
} from 'react-native-paper';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { auth } from '../utils/firebase';

type RegisterScreenProps = {
  navigation: any;
};

const RegisterScreen: React.FC<RegisterScreenProps> = ({ navigation }) => {
  const theme = useTheme();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [showEmailRegister, setShowEmailRegister] = useState(false);

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  const handleEmailRegister = async () => {
    if (!email || !password || !confirmPassword) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    if (!validateEmail(email)) {
      Alert.alert('Error', 'Please enter a valid email address');
      return;
    }

    if (password.length < 6) {
      Alert.alert('Error', 'Password must be at least 6 characters long');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('Error', 'Passwords do not match');
      return;
    }

    setLoading(true);
    try {
      await createUserWithEmailAndPassword(auth, email, password);
      // Navigation will be handled by the auth state listener
    } catch (error: any) {
      Alert.alert('Registration Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleRegister = async () => {
    Alert.alert('Coming Soon', 'Google sign-up will be implemented soon!');
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContainer: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
      paddingVertical: 40,
    },
    surface: {
      padding: 24,
      borderRadius: 16,
      marginBottom: 24,
      elevation: 4,
    },
    title: {
      fontSize: 32,
      fontWeight: 'bold',
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 8,
    },
    subtitle: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 32,
    },
    socialButtonsContainer: {
      gap: 16,
      marginBottom: 24,
    },
    socialButton: {
      paddingVertical: 12,
      borderRadius: 12,
      borderWidth: 1,
      borderColor: theme.colors.outline,
    },
    socialButtonContent: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 12,
    },
    socialButtonText: {
      fontSize: 16,
      fontWeight: '500',
    },
    dividerContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      marginVertical: 24,
      gap: 16,
    },
    dividerLine: {
      flex: 1,
      height: 1,
      backgroundColor: theme.colors.outline,
    },
    dividerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    emailContainer: {
      gap: 16,
    },
    textInput: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
    },
    passwordContainer: {
      position: 'relative',
    },
    registerButton: {
      paddingVertical: 12,
      borderRadius: 12,
      marginTop: 8,
    },
    backButton: {
      alignSelf: 'center',
      marginTop: 16,
    },
    footer: {
      flexDirection: 'row',
      justifyContent: 'center',
      alignItems: 'center',
      marginTop: 24,
      gap: 4,
    },
    footerText: {
      fontSize: 14,
      color: theme.colors.onSurfaceVariant,
    },
    loginLink: {
      fontSize: 14,
      color: theme.colors.primary,
      fontWeight: '500',
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
    },
  });

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.surface}>
          <Text style={styles.title}>Create Account</Text>
          <Text style={styles.subtitle}>Sign up to get started</Text>

          {!showEmailRegister ? (
            <>
              <View style={styles.socialButtonsContainer}>
                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={handleGoogleRegister}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Google</Text>
                  </View>
                </Button>

                <Button
                  mode="outlined"
                  style={styles.socialButton}
                  onPress={() => setShowEmailRegister(true)}
                  disabled={loading}
                >
                  <View style={styles.socialButtonContent}>
                    <Text style={styles.socialButtonText}>Continue with Email</Text>
                  </View>
                </Button>
              </View>
            </>
          ) : (
            <>
              <View style={styles.dividerContainer}>
                <View style={styles.dividerLine} />
                <Text style={styles.dividerText}>Email Registration</Text>
                <View style={styles.dividerLine} />
              </View>

              <View style={styles.emailContainer}>
                <TextInput
                  mode="outlined"
                  label="Email"
                  value={email}
                  onChangeText={setEmail}
                  keyboardType="email-address"
                  autoCapitalize="none"
                  style={styles.textInput}
                  disabled={loading}
                />

                <View style={styles.passwordContainer}>
                  <TextInput
                    mode="outlined"
                    label="Password"
                    value={password}
                    onChangeText={setPassword}
                    secureTextEntry={!showPassword}
                    style={styles.textInput}
                    disabled={loading}
                    right={
                      <TextInput.Icon
                        icon={showPassword ? 'eye-off' : 'eye'}
                        onPress={() => setShowPassword(!showPassword)}
                      />
                    }
                  />
                </View>

                <View style={styles.passwordContainer}>
                  <TextInput
                    mode="outlined"
                    label="Confirm Password"
                    value={confirmPassword}
                    onChangeText={setConfirmPassword}
                    secureTextEntry={!showConfirmPassword}
                    style={styles.textInput}
                    disabled={loading}
                    right={
                      <TextInput.Icon
                        icon={showConfirmPassword ? 'eye-off' : 'eye'}
                        onPress={() => setShowConfirmPassword(!showConfirmPassword)}
                      />
                    }
                  />
                </View>

                <Button
                  mode="contained"
                  onPress={handleEmailRegister}
                  style={styles.registerButton}
                  disabled={loading}
                >
                  {loading ? (
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.colors.onPrimary} />
                      <Text style={{ color: theme.colors.onPrimary }}>Creating account...</Text>
                    </View>
                  ) : (
                    'Create Account'
                  )}
                </Button>

                <Button
                  mode="text"
                  onPress={() => setShowEmailRegister(false)}
                  style={styles.backButton}
                  disabled={loading}
                >
                  Back to options
                </Button>
              </View>
            </>
          )}

          <View style={styles.footer}>
            <Text style={styles.footerText}>Already have an account?</Text>
            <Button
              mode="text"
              onPress={() => navigation.navigate('Login')}
              disabled={loading}
            >
              <Text style={styles.loginLink}>Sign in</Text>
            </Button>
          </View>
        </Surface>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default RegisterScreen;

END OF RegisterScreen.tsx>

UserCreationScreen.tsx<

// src/screens/UserCreationScreen.tsx

import React, { useState } from 'react';
import {
  View,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import {
  Button,
  Text,
  TextInput,
  Surface,
  useTheme,
  ActivityIndicator,
  HelperText,
} from 'react-native-paper';
import { doc, setDoc, query, where, getDocs, collection } from 'firebase/firestore';
import { auth, firestore } from '../utils/firebase';

type UserCreationScreenProps = {
  navigation: any;
};

const UserCreationScreen: React.FC<UserCreationScreenProps> = ({ navigation }) => {
  const theme = useTheme();
  const [username, setUsername] = useState('');
  const [loading, setLoading] = useState(false);
  const [usernameError, setUsernameError] = useState('');
  const [checkingUsername, setCheckingUsername] = useState(false);

  const validateUsername = (username: string) => {
    const regex = /^[a-zA-Z0-9_]+$/;
    if (!username) {
      return 'Username is required';
    }
    if (username.length < 3) {
      return 'Username must be at least 3 characters long';
    }
    if (username.length > 20) {
      return 'Username must be less than 20 characters';
    }
    if (!regex.test(username)) {
      return 'Username can only contain letters, numbers, and underscores';
    }
    return '';
  };

  const checkUsernameAvailability = async (username: string) => {
    setCheckingUsername(true);
    try {
      const q = query(
        collection(firestore, 'users'),
        where('username', '==', username)
      );
      const querySnapshot = await getDocs(q);
      return querySnapshot.empty;
    } catch (error) {
      console.error('Error checking username availability:', error);
      return false;
    } finally {
      setCheckingUsername(false);
    }
  };

  const handleUsernameChange = async (text: string) => {
    setUsername(text);
    const validationError = validateUsername(text);
    
    if (validationError) {
      setUsernameError(validationError);
      return;
    }

    // Check availability after validation passes
    const isAvailable = await checkUsernameAvailability(text);
    if (!isAvailable) {
      setUsernameError('Username is already taken');
    } else {
      setUsernameError('');
    }
  };

  const handleCreateProfile = async () => {
    const validationError = validateUsername(username);
    if (validationError) {
      setUsernameError(validationError);
      return;
    }

    if (usernameError) {
      Alert.alert('Error', usernameError);
      return;
    }

    setLoading(true);
    try {
      const user = auth.currentUser;
      if (!user) {
        throw new Error('No authenticated user found');
      }

      // Double-check username availability
      const isAvailable = await checkUsernameAvailability(username);
      if (!isAvailable) {
        setUsernameError('Username is already taken');
        setLoading(false);
        return;
      }

      // Create user profile
      await setDoc(doc(firestore, 'users', user.uid), {
        uid: user.uid,
        username: username,
        email: user.email,
        createdAt: new Date().toISOString(),
      });

      Alert.alert('Success', 'Profile created successfully!');
    } catch (error: any) {
      Alert.alert('Error', error.message);
    } finally {
      setLoading(false);
    }
  };

  const styles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
    },
    scrollContainer: {
      flexGrow: 1,
      justifyContent: 'center',
      paddingHorizontal: 24,
      paddingVertical: 40,
    },
    surface: {
      padding: 24,
      borderRadius: 16,
      elevation: 4,
    },
    title: {
      fontSize: 32,
      fontWeight: 'bold',
      color: theme.colors.primary,
      textAlign: 'center',
      marginBottom: 8,
    },
    subtitle: {
      fontSize: 16,
      color: theme.colors.onSurfaceVariant,
      textAlign: 'center',
      marginBottom: 32,
      lineHeight: 24,
    },
    inputContainer: {
      marginBottom: 24,
    },
    textInput: {
      backgroundColor: theme.colors.surface,
      borderRadius: 12,
      marginBottom: 8,
    },
    helperText: {
      fontSize: 12,
      marginTop: 4,
    },
    createButton: {
      paddingVertical: 12,
      borderRadius: 12,
      marginTop: 16,
    },
    loadingContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
    },
    usernameContainer: {
      position: 'relative',
    },
    checkingIndicator: {
      position: 'absolute',
      right: 16,
      top: 20,
    },
  });

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        <Surface style={styles.surface}>
          <Text style={styles.title}>Complete Setup</Text>
          <Text style={styles.subtitle}>
            Choose a unique username
          </Text>

          <View style={styles.inputContainer}>
            <View style={styles.usernameContainer}>
              <TextInput
                mode="outlined"
                label="Username"
                value={username}
                onChangeText={handleUsernameChange}
                style={styles.textInput}
                disabled={loading}
                error={!!usernameError}
                autoCapitalize="none"
                placeholder="Enter your username"
              />
              {checkingUsername && (
                <ActivityIndicator
                  size="small"
                  color={theme.colors.primary}
                  style={styles.checkingIndicator}
                />
              )}
            </View>
            
            <HelperText 
              type={usernameError ? 'error' : 'info'} 
              visible={!!usernameError || !usernameError && username.length > 0}
              style={styles.helperText}
            >
              {usernameError || 'Username can contain letters, numbers, and underscores'}
            </HelperText>
          </View>

          <Button
            mode="contained"
            onPress={handleCreateProfile}
            style={styles.createButton}
            disabled={loading || !!usernameError || !username || checkingUsername}
          >
            {loading ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="small" color={theme.colors.onPrimary} />
                <Text style={{ color: theme.colors.onPrimary }}>Creating profile...</Text>
              </View>
            ) : (
              'Complete Setup'
            )}
          </Button>
        </Surface>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

export default UserCreationScreen;

END OF UserCreationScreen.tsx>

ProfileScreen.tsx<

// src/screens/ProfileScreen.tsx

import React from 'react';
import { View, StyleSheet, SafeAreaView } from 'react-native';
import { Text, Button, useTheme } from 'react-native-paper';
import { signOut } from 'firebase/auth';
import { auth } from '../utils/firebase';

const ProfileScreen: React.FC = () => {
  const theme = useTheme();
  const user = auth.currentUser;

  const handleSignOut = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.error('Sign out error:', error);
    }
  };

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <View style={styles.content}>
        <Text style={[styles.title, { color: theme.colors.primary }]}>Profile</Text>
        <Text style={[styles.email, { color: theme.colors.onSurfaceVariant }]}>{user?.email}</Text>
        <Button
          mode="contained"
          onPress={handleSignOut}
          style={styles.signOutButton}
        >
          Sign Out
        </Button>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  email: {
    fontSize: 16,
    marginBottom: 32,
    opacity: 0.8,
  },
  signOutButton: {
    paddingHorizontal: 32,
    paddingVertical: 8,
    borderRadius: 8,
  },
});

export default ProfileScreen;

END OF ProfileScreen.tsx>

firebase.ts<

// src/utils/firebase.ts

import { initializeApp } from 'firebase/app';
import { getFirestore } from 'firebase/firestore';
import { getAuth } from 'firebase/auth';
import Constants from 'expo-constants';

const firebaseConfig = {
  apiKey: Constants.expoConfig?.extra?.FIREBASE_API_KEY,
  authDomain: Constants.expoConfig?.extra?.FIREBASE_AUTH_DOMAIN,
  projectId: Constants.expoConfig?.extra?.FIREBASE_PROJECT_ID,
  storageBucket: Constants.expoConfig?.extra?.FIREBASE_STORAGE_BUCKET,
  messagingSenderId: Constants.expoConfig?.extra?.FIREBASE_MESSAGING_SENDER_ID,
  appId: Constants.expoConfig?.extra?.FIREBASE_APP_ID,
  measurementId: Constants.expoConfig?.extra?.FIREBASE_MEASUREMENT_ID
};

const app = initializeApp(firebaseConfig);
const firestore = getFirestore(app);
const auth = getAuth(app);

export { firestore, auth };

END OF firebase.ts>

quizUtils.ts<

// src/utils/quizUtils.ts

import { 
  collection, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs,
  doc,
  setDoc,
  getDoc,
  DocumentData
} from 'firebase/firestore';
import { firestore } from './firebase';

interface Question {
  id: string;
  question: string;
  options: string[];
  correctAnswer: number;
  animeId?: number;
  animeName?: string;
  random: number;
}

interface DailyQuestions {
  date: string;
  category: string;
  questions: Question[];
  generatedAt: Date;
}

/**
 * Get the current UTC date in YYYY-MM-DD format
 */
export const getUTCDateString = (): string => {
  const now = new Date();
  const year = now.getUTCFullYear();
  const month = String(now.getUTCMonth() + 1).padStart(2, '0');
  const day = String(now.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

/**
 * Generate a seed number from a date string and category
 */
const generateDailySeed = (dateString: string, category: string): number => {
  let hash = 0;
  const str = `${dateString}-${category}`;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash);
};

/**
 * Get daily questions for a specific category
 */
export const getDailyQuestions = async (
  animeId: number | null,
  questionCount: number = 10
): Promise<Question[]> => {
  const dateString = getUTCDateString();
  const category = animeId === null ? 'all' : animeId.toString();
  const dailyQuestionId = `${dateString}_${category}`;

  try {
    // First, check if we already have questions for today
    const dailyQuestionDoc = await getDoc(
      doc(firestore, 'dailyQuestions', dailyQuestionId)
    );

    if (dailyQuestionDoc.exists()) {
      const data = dailyQuestionDoc.data() as DailyQuestions;
      console.log(`Using cached questions for ${category} on ${dateString}`);
      return data.questions;
    }

    // If not, generate new questions for today
    console.log(`Generating new questions for ${category} on ${dateString}`);
    const seed = generateDailySeed(dateString, category);
    
    // Use modulo to create "buckets" for deterministic selection
    const bucketSize = 1000;
    const targetBucket = seed % bucketSize;

    // Fetch questions using the random field for efficient querying
    let questionsQuery;
    if (animeId === null) {
      // For "all" category, fetch from all questions
      questionsQuery = query(
        collection(firestore, 'questions'),
        where('random', '>=', targetBucket),
        where('random', '<', targetBucket + 100),
        orderBy('random'),
        limit(questionCount * 2) // Fetch extra in case we need them
      );
    } else {
      // For specific anime
      questionsQuery = query(
        collection(firestore, 'questions'),
        where('animeId', '==', animeId),
        where('random', '>=', targetBucket),
        where('random', '<', targetBucket + 100),
        orderBy('random'),
        limit(questionCount * 2)
      );
    }

    let snapshot = await getDocs(questionsQuery);
    let questions: Question[] = [];

    // If we didn't get enough questions in the target bucket, wrap around
    if (snapshot.size < questionCount) {
      if (animeId === null) {
        questionsQuery = query(
          collection(firestore, 'questions'),
          orderBy('random'),
          limit(questionCount * 3)
        );
      } else {
        questionsQuery = query(
          collection(firestore, 'questions'),
          where('animeId', '==', animeId),
          orderBy('random'),
          limit(questionCount * 3)
        );
      }
      snapshot = await getDocs(questionsQuery);
    }

    // Convert to Question array
    snapshot.forEach((doc) => {
      const data = doc.data();
      questions.push({
        id: doc.id,
        question: data.question,
        options: data.options,
        correctAnswer: data.correctAnswer,
        animeId: data.animeId,
        animeName: data.animeName,
        random: data.random,
      });
    });

    // Use the seed to deterministically select from available questions
    const selectedQuestions: Question[] = [];
    const availableIndices = questions.map((_, index) => index);
    
    for (let i = 0; i < Math.min(questionCount, questions.length); i++) {
      const seedForIndex = (seed + i) % availableIndices.length;
      const selectedIndex = availableIndices[seedForIndex];
      selectedQuestions.push(questions[selectedIndex]);
      availableIndices.splice(seedForIndex, 1);
    }

    // Cache the selected questions for today
    const dailyQuestionsData: DailyQuestions = {
      date: dateString,
      category,
      questions: selectedQuestions,
      generatedAt: new Date(),
    };

    await setDoc(
      doc(firestore, 'dailyQuestions', dailyQuestionId),
      dailyQuestionsData
    );

    return selectedQuestions;
  } catch (error) {
    console.error('Error fetching daily questions:', error);
    throw error;
  }
};

/**
 * Check if the user has already played today (based on UTC time)
 */
export const hasPlayedToday = async (
  userId: string,
  category: string
): Promise<boolean> => {
  const dateString = getUTCDateString();
  
  const attemptQuery = query(
    collection(firestore, 'dailyQuizzes'),
    where('userId', '==', userId),
    where('date', '==', dateString),
    where('category', '==', category)
  );

  const snapshot = await getDocs(attemptQuery);
  return !snapshot.empty;
};

/**
 * Get time until next UTC midnight
 */
export const getTimeUntilReset = (): { hours: number; minutes: number; seconds: number } => {
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);
  tomorrow.setUTCHours(0, 0, 0, 0);
  
  const diff = tomorrow.getTime() - now.getTime();
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  
  return { hours, minutes, seconds };
};

END OF quizUtils.ts>

theme.ts<

// src/themes/theme.ts

import { MD3DarkTheme, configureFonts } from 'react-native-paper';

const fontConfig = {
  displayLarge: {
    fontFamily: 'System',
    fontSize: 57,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 64,
  },
  displayMedium: {
    fontFamily: 'System',
    fontSize: 45,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 52,
  },
  displaySmall: {
    fontFamily: 'System',
    fontSize: 36,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 44,
  },
  headlineLarge: {
    fontFamily: 'System',
    fontSize: 32,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 40,
  },
  headlineMedium: {
    fontFamily: 'System',
    fontSize: 28,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 36,
  },
  headlineSmall: {
    fontFamily: 'System',
    fontSize: 24,
    fontWeight: '400' as const,
    letterSpacing: 0,
    lineHeight: 32,
  },
  titleLarge: {
    fontFamily: 'System',
    fontSize: 22,
    fontWeight: '500' as const,
    letterSpacing: 0,
    lineHeight: 28,
  },
  titleMedium: {
    fontFamily: 'System',
    fontSize: 16,
    fontWeight: '500' as const,
    letterSpacing: 0.1,
    lineHeight: 24,
  },
  titleSmall: {
    fontFamily: 'System',
    fontSize: 14,
    fontWeight: '500' as const,
    letterSpacing: 0.1,
    lineHeight: 20,
  },
  labelLarge: {
    fontFamily: 'System',
    fontSize: 14,
    fontWeight: '500' as const,
    letterSpacing: 0.1,
    lineHeight: 20,
  },
  labelMedium: {
    fontFamily: 'System',
    fontSize: 12,
    fontWeight: '500' as const,
    letterSpacing: 0.5,
    lineHeight: 16,
  },
  labelSmall: {
    fontFamily: 'System',
    fontSize: 11,
    fontWeight: '500' as const,
    letterSpacing: 0.5,
    lineHeight: 16,
  },
  bodyLarge: {
    fontFamily: 'System',
    fontSize: 16,
    fontWeight: '400' as const,
    letterSpacing: 0.5,
    lineHeight: 24,
  },
  bodyMedium: {
    fontFamily: 'System',
    fontSize: 14,
    fontWeight: '400' as const,
    letterSpacing: 0.25,
    lineHeight: 20,
  },
  bodySmall: {
    fontFamily: 'System',
    fontSize: 12,
    fontWeight: '400' as const,
    letterSpacing: 0.4,
    lineHeight: 16,
  },
};

export const customDarkTheme = {
  ...MD3DarkTheme,
  fonts: configureFonts({ config: fontConfig }),
  colors: {
    ...MD3DarkTheme.colors,
    primary: '#6C5CE7',
    primaryContainer: '#4834D4',
    secondary: '#A29BFE',
    secondaryContainer: '#6C5CE7',
    tertiary: '#FD79A8',
    tertiaryContainer: '#E84393',
    surface: '#1E1E1E',
    surfaceVariant: '#2A2A2A',
    background: '#121212',
    error: '#FF6B6B',
    errorContainer: '#FF5252',
    onPrimary: '#FFFFFF',
    onPrimaryContainer: '#FFFFFF',
    onSecondary: '#FFFFFF',
    onSecondaryContainer: '#FFFFFF',
    onTertiary: '#FFFFFF',
    onTertiaryContainer: '#FFFFFF',
    onSurface: '#FFFFFF',
    onSurfaceVariant: '#CCCCCC',
    onBackground: '#FFFFFF',
    onError: '#FFFFFF',
    onErrorContainer: '#FFFFFF',
    outline: '#666666',
    outlineVariant: '#444444',
    shadow: '#000000',
    scrim: '#000000',
    inverseSurface: '#FFFFFF',
    inverseOnSurface: '#000000',
    inversePrimary: '#6C5CE7',
    elevation: {
      level0: 'transparent',
      level1: '#1E1E1E',
      level2: '#2A2A2A',
      level3: '#363636',
      level4: '#404040',
      level5: '#4A4A4A',
    },
    surfaceDisabled: '#1E1E1E',
    onSurfaceDisabled: '#666666',
    backdrop: 'rgba(0, 0, 0, 0.4)',
  },
};

export default customDarkTheme;

END OF theme.ts>

App.tsx<

// App.tsx

import React from 'react';
import { Provider as PaperProvider } from 'react-native-paper';
import { StatusBar } from 'expo-status-bar';
import AppNavigator from './src/navigation/AppNavigator';
import customDarkTheme from './src/themes/theme';

const App: React.FC = () => {
  return (
    <PaperProvider theme={customDarkTheme}>
      <StatusBar style="light" />
      <AppNavigator />
    </PaperProvider>
  );
};

export default App;

END OF App.tsx>

